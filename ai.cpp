#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")

// Reversi AI C++ version 5
// previous 11th rate 30.44
// use Negascout

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <string>
#include <unordered_map>
#include <random>

using namespace std;

#define hw 8
#define hw_m1 7
#define hw_p1 9
#define hw2 64
#define hw2_m1 63
#define hw2_mhw 56
#define window 0.00001
#define simple_threshold 3
#define inf 100000.0
#define param_num 36
#define board_index_num 38
#define pattern_num 5
#define char_s 35
#define char_e 91
#define num_s 93
#define num_e 126
#define pattern_elem_num 85293
#define hash_table_size 16384
#define hash_mask (hash_table_size - 1)

const double params[param_num + hw2 + 10] = {
    0.00, 0.00, 0.00, 0.00, 4.00, 3.00, 4.00, 2.00,
    9.00, 5.00, 6.00, 6.00, 5.00, 8.38, 5.69, 9.13,
    5.45, 6.98, 6.66, 9.38, 6.98, 9.29, 7.29, 9.32, 
    7.37, 9.94, 7.14, 9.78, 7.31, 10.95, 7.18, 9.78, 
    7.76, 9.21, 7.33, 8.81, 7.20, 8.48, 7.23, 8.00, 
    6.92, 7.57, 6.62, 7.13, 6.38, 6.54, 5.96, 6.18, 
    5.62, 5.64, 5.18, 5.18, 4.60, 4.48, 4.06, 3.67, 
    3.39, 3.11, 2.66, 2.30, 1.98, 1.53, 1.78, 0.67,

    0.2880, -0.1150, 0.0000, -0.0096,
            -0.1542, -0.0288, -0.0288,
                    0.0000, -0.0096,
                            -0.0096,

    //pattern
    0.7,
    1.8,
    2.0,

    //cnt
    -0.1811547613418304,
    0.12256421779943,
    0.159657943106798,

    //canput
    0.6064154229278483,
    0.95108513784618123,
    0.3008915374395087,

    //weight
    1.5074239387106616,
    1.4748191052602565,
    0.50072611426043,

    //confirm
    1.7570085089149844,
    1.9588640141207756,
    2.052469793113826,

    //pot_canput
    3.2376773352635188,
    3.3740480754567749,
    1.5350314798267053,

    //open
    1.7,
    2.2,
    0.7,

    //edgex
    0.474054,
    0.345462,
    0.472862,

    //corner
    0.125835,
    0.168511,
    0.139245,

    //corner24
    0.2,
    0.499800,
    0.144653,

    //diagonal
    -0.552854,
    0.247642,
    0.314905,

    //edge
    0.537790,
    0.315670,
    0.170627
};

const int consts[476] = {
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
    62, 63, 0, 8, 16, 24, 32, 40, 48, 56, 1, 9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 4, 12, 20, 28, 36, 44, 52, 60, 5, 13, 21, 29, 37, 45, 53, 61, 6, 14, 22, 30, 38, 46, 54, 62, 7, 15, 23, 31, 39, 47, 55, 63, 5, 14, 23, 4, 13, 22, 31, 3, 12, 21, 30, 39, 2, 11, 20, 29, 38, 47, 1, 10, 19, 28, 37, 46, 55, 0, 9, 18, 27, 36, 45, 54, 63, 8,
    17, 26, 35, 44, 53, 62, 16, 25, 34, 43, 52, 61, 24, 33, 42, 51, 60, 32, 41, 50, 59, 40, 49, 58, 2, 9, 16, 3, 10, 17, 24, 4, 11, 18, 25, 32, 5, 12, 19, 26, 33, 40, 6, 13, 20, 27, 34, 41, 48, 7, 14, 21, 28, 35, 42, 49, 56, 15, 22, 29, 36, 43, 50, 57, 23, 30, 37, 44, 51, 58, 31, 38, 45, 52, 59, 39, 46, 53, 60, 47, 54, 61, 10, 8, 8, 8, 8, 4, 4, 8, 2, 4, 54, 63, 62, 61, 60, 59, 58, 57,
    56, 49, 49, 56, 48, 40, 32, 24, 16, 8, 0, 9, 9, 0, 1, 2, 3, 4, 5, 6, 7, 14, 14, 7, 15, 23, 31, 39, 47, 55, 63, 54, 3, 2, 1, 0, 9, 8, 16, 24, 4, 5, 6, 7, 14, 15, 23, 31, 60, 61, 62, 63, 54, 55, 47, 39, 59, 58, 57, 56, 49, 48, 40, 32, 0, 1, 2, 3, 8, 9, 10, 11, 0, 8, 16, 24, 1, 9, 17, 25, 7, 6, 5, 4, 15, 14, 13, 12, 7, 15, 23, 31, 6, 14, 22, 30, 63, 62, 61, 60,
    55, 54, 53, 52, 63, 55, 47, 39, 62, 54, 46, 38, 56, 57, 58, 59, 48, 49, 50, 51, 56, 48, 40, 32, 57, 49, 41, 33, 0, 9, 18, 27, 36, 45, 54, 63, 7, 14, 21, 28, 35, 42, 49, 56, 0, 1, 2, 3, 4, 5, 6, 7, 7, 15, 23, 31, 39, 47, 55, 63, 63, 62, 61, 60, 59, 58, 57, 56, 56, 48, 40, 32, 24, 26, 8, 0
};

const string super_compress_pattern = 
"?@=:]@D=D<A4?;?];.AJ<?PB?]C@=A6=9/<@6GJDA8?:<?JC%A]/5K=]AO=AHE@?:3N2IY=]H37?BD9E=>B=59CEA=IB?`=?C(G?A]?JC=@<@B:?/B>@7CGD?BDALE?9B?H<@=9E?AC'@9?cD/=?C:LM5@]<9A=H;E:6V?:3?<]5?<?]@?^=EA:=W9=?:@O2H0?D:E?c@B>?;O=D;=81?B5?;D@G>?:<:96>DAE8.?]G<@G?A)?DJ>/9?1E?^<=>?/?9/;JE?]CB?6?]EC?]39]0=A]?EFG9C;3U?@2?CODF"
"]?38^C=8;B7%#?7?6?a5F?^R?9?]>]A07CG]=]<?@A@;]BF.A?>?]L7<C@?@CH?>?dG?H?G>?]B?=<?<8<?8;F/?:?^UI-C?RC?_:B?=?JHE4B,?F;J^?d=A]?9F/?D]<O?:3?E?BK=?7:F]>@<9>6?9PE?EN?_9MB6=?3:?U<A=]7:E?89:78F;F?EJB(J?/;?L=A@]ECN?]O?;9ENE?J?3?9?]G?;:?B@AE?]EB5;Q?_:,BO8?)?^DA<]O:?]8E;@27@8?CF:/B?]9?KD?;D396?]A?dIR<3]4?C8@BE[F"
"?;YF7>?E?_,?]H?H?_A>;6@?];>65?];?^6?e=@6@7M:F8<P?G2?^A?BC;B>=]@A@5E9CA9YU?`;?],M?OM?^@?E]BNJ<E;=9?BA9FBA5DEG]?-N?@<?F:1?DKD?]<?]6?E3I?PE?]9<5=HE?]/]?d@?B?OH?^BM9?(?`;]I<=DE]>?<?]=?]J@<9IDH3?E?dE?5IA6)]?A];C@9?45@;@?13?KM:?1?7Z?]/AH?9=9?^<?J,8;?]0:?cEAC?BG9?<:7?]8/?IDB8<N@?=<D=B<8;R3RF9C7?A?]8AH?9?]N"
"?]IB/;?3B?^O)?]9?]3?B?9?E=?3R9F?];03?>BJ?]/W?>D936?4KQIJ><A<A4'A=E5?E]?]97B?<?=<;O9@?]8=C@>A>]?EA<6>@CB=?A?H:<]>;O:A5]=KC?/?`B39?.6JC7ABDEHI,]@DJ9?A?]/?*?6?2C?^A1A?:?]J5?3?]:2?9?f:C?;2<3<?=J?8:?4?E0<?<]C<]=78?;=UDH@<A?/?EG<@?D?92?^A1I;B?^C9H?G5?]F?3?_I?^=@>/BE7EG<P?/I?383J38?RA?;7?=A=H7?2K?_6?_/?OU9"
"/?]3AHD@AOJ?I<DI=@A?K?DYO?`3?vAD=I>8O>7A@<?7E]MEI?C?@/?]C]>]:@BR?C:2J8B7?A39?3?aA^E<49/A;N?]@]?A@A@AJD=8>=]>=;D<HE9>0R?_0/%?)?]C?_B>M9?]D894J?E?]9.3?:?]G?]B=9>38B90<=9I?/Q976BE@E;7?<;=C<?HJ;E=DL?]O?]$G>]C?12?JM9:=EA?]6<]BEA:B0?=C?F?:5?OF=>5?^DE@C?cA3?]M?RCEA@H?O]6?8>;?`5/?d=DAJ8?56:8I?U?U5G=?d<D1?`V"
"?B?]3?]@?]B]9^4@B@F](69?@C=9?`LE=<A9A7?]O@?>F79O9;3FJ?GB?=,A?.JKFO?4=4L?;?B?;J?a5?E?5?]87?H<A:/F@4F@5:?];?]N><A>9]1?9F<]=E=O9JB<]>E@?4A:C?0?=]?=>;@],;?C<=EJ?bD3K?K=FG<?=A?3LAF6N.?]J?)OE?cH?v<:534?=/<9.%?J?_B4:?]2A=>@A<J7,E,C6E?]5?]0?EG;?=E?]<E?8J?^NCEGJ-4]?2I<?3?9@?'O<CO?_<J<E?],J?@9/?U?]J?]E=:;R=R9"
"5]SH?`:L9E3?]O?]=?;CABJ?LB9AN:A]?B]?3A?]J?DF<=M?H3?]D?fJ?]E?LC?=AW@<BI<]B?BD/?B@8?H?FE9?9AB?IAH/=D;DJ3F;?GO3?;?^O?]>_=?F;@;@<6BD?]=?>@H=?9A=<LE?^#?AE3?]/?gJY?J?9J?l9?]J>?M?`,O?cB?`'?]<=8?3?,9]?d=?;?J]?]9]J:6]?_GA9?<]?]A?]A?94?J9=?J?3?m3?a3?_,5?Z?^%?f@HX?P?b,;,?g6?b'?`3?]J=?@?]3?]HI?E?~?kD?c/?c,?`/?o"
"@?cE@O?aJ?9<?3?]J?d5?2?p/?]53E?z3?nS?l2%9?]/?^:92?)?^95?cA?D?a@=2?J?]3=DR/?3B?<?d@>?hE?g;?Y,)?k,?`D&E6<?]/?M;?2D1?C?B?aB&NY?aM?k347R7?3?3?^B;?:93?3=?cA>?]J?^E?_:?]A3=?5?a<=BAB@G?3F?^9?O8HB^DED7<>6X7?J?^X?d;?c;9AU0?cR?_/?R?E9?^9B?aB?bB?a9?]3J?uO?O?aJ?_9?^/?c3?J$?l$]?_:?^J?_D7E?^%?%R?c9]?fR?^%R?R?aEG<"
"?L?_759?R?]J?<?@?9G?]E>8@?I/?]EGCK?N?]E]@?/?CG?]G?7B?9?9?0J?^<C?/?L?^J]?]C<@?JE?@?,D?J?3R9?]B;EX<MC?<=<]NBC;A6JL?]9?]7;<=;H>I7]3>9=E>D:^A<@B]=:^?>BE>:6C7<=4J9>#0;O?O?>O?^73=HE8?=0;3;?C9?]=M3Z?aK/?]J?^/<;=?`)IB?]=J?)?e9&>J43?],J?`9]?^AX=]?E@:?/?lE?a<#?U6?cR?_/?^E?_8D@?`E?b1?cO?4/?uE?bI?JO3F?~?_6RA?'?"
"q:9?]/?R?aR9?3%?d;D<?`<?bE?F]D?93?E@?O9?`BO?^/?hK)]?E?^)?_/?d3?]J=-G?E?^,?dO?`'?];?6?a/?bJ?3?`J?BEA?3?]3?DHUO=?aI?95?]9J?<?J?hO?_J?9?]A?3?_,?]Z?j<?^E?cO?h<?g3?_1?@?]3?]J9?E?bE?~?cC?dE?b,?u@?cK@O?O?_O?96E2?^9?cE?~?~?~?]=?J?`E?b;?]G?aO:41?`97?<?hO?]/?kO?`O]?D?Y?9?h;?aJ?]0?`3]J9?HB2?E?cQ&9E?r3589E?J?^D"
"FB3?_#?e;]3?_3;?^E2E?]3E?,?a;>=E5?J?>?_9?OBH>=A]?O<=?A91[<?c3?_8?J?`O?1?]R?_;?]W?`/?c%3?`3E?_3?]E?e>?^R?J?fH#?Y?`H?^W?_@=?]5?]J?`3?]J?=&5?`-?jR]B]FARE]?]KAC?]E?]3]?d@3?aJ?bJ?eED3?^H?G?<?]E3?JE7E=?=?]BACKE?E?^U=:?bH?c@?s9?>KA?AJ?]3?_=?_:O,?]A?<JFG,J?_J@?c>B;J]?]EDB<@7K?<=;<;<F?A9:97?]/5F?]E<?@?9?^3@H"
"?fJ=?]DB%?_R?U?aR?f/?$?1?cJ]?g98X?]OH?B;?^X<?^0?B?];LM959?t:?cR?]O?`O?~I9J?s*?cKEY?_O?jJ?y=?lIK?eO?i8/>?j3E?]3?BJ?]E/?;?h/?bOA7Q?R?^9/?]W?i3U]?U?^9?_3?]J?dO?]<?R?J?g#?bB?cL=?]3?]J?dJA?b9?l/BH?dJ?]3?^O?^3?_3B?a3/?_E?3?e<=9?]J?]K?5?]E?]HE9(5?^/?A]3?]9?a7?/?dB?^>?O?a/?]/?/?gCLJ?E?d/?^GB?bF9E?:?^4?d7J;?"
"][?^CA?3?]9?H?<A]?A</>?^/5<?]ECJC?BJ?^9R?fJ?9]K:%?aEB?_3?gD?9?eHJ?iN?J]?bX-?^3?E?]95L<E9?m9?a:?cR?e9?~?~?~?m=?l9?u3/>?`/E?c/E?_HK9HG&?&?^3B?lE?<?<?cJ?]E?a<?^B<E?^)?NO,?`E9?c,D?b3,?c:9GY]?_9B7?`1B>?]9?]7EGEI?]3?],E?E?a,]?fY?^,3?uJ3?_Y?cY?Y?d/]?bO?c3?aE?DO?c9?kE=9?9?d/?cM?^A?Z?^)?HO?b9?c,G=,?`W?mB]:?B"
"?_7:8?>9?JE?`9?^D?E,?_O?hYJ?D,I?O?~?m9?j43?_/8J@=E?8?]O4=O?]7?]7;72:?9]?]/B>]=R?3?8<8B;B?&0A93?E?^,J?<FEN?^E1?^;?]3^?_O?;ABCJ?A?]E;2?O?O?^40#J?aE?X?R?3JI?=?]>9&A]3?]E?E?^B@B?U?h4?<?]U?3A]B^G=/:;B]@GJG5]@3?2?CG?]EAI@[CN3?EF@K?M@5F8/]?`/?]@EC]D9:@><?HF;8C?=]AD]C;@;:H.?A?h[]K?a5,?]O?],]?W?j,;/E?sE?u8?A"
"?b3?^E?]3?d(%?t>3?a=?b3?^9?`O?_O?cO?gOJHJ?J?mJ?]65O?a3?E?kH?}E?lEB?lJ?c<?`R?]N/B9IE?,/?`-R]G/?I?J?lQE?^A?c,?l=?uR?bE?kD@9?c3?cR?I?aC?v9?b3?e3?^3?xE?J?]J?~?e3?][?uI?uW?K?hJEBZH?]J?9T6?K?lD?,?_E?cU?lM?p,J?`,?~?_O?fF?,?,?m/?^7?O?O?q;?cU?_E?gJ?_J?g=]?_:?]@?c6?~?dE?qR?^0%=?=?]Z?e7?9?9?^Z8?EBE%?)CE]BA=@?B"
"?393B?C?E@E?_;?k9$?^O?c6?l@?uAO9?`A?_3?eE?@:?u9?uJ?^X?j3?]J?]E?wK?c9?^R?~?_6?3?F3?p:9B?`D?9J?E]?B?eIJ?],?^J?bC?[3I?)3?J]O?^E?~?i3?~?vJO?^Q?]O?`E?yE?b3?m/?~?dE]?`E?EO?iE?eI?c$?t9?lE?E?tO?cJ?]9]P?LO?cJ,A?k,?,?a3?^O?]J?mJ?zO?pR?~?i/?gO?bO?mE?vJ?^EJ?LM?cU3?)?U?j)?]U?^6?^R?,?]A?lE?^9?q>E@X?_>E9?X3X?DJC8D"
"?:=?E<?]%?~?m%?%?~?~?~?~?^O?~?J?~?u%?c%?~?`E?~?~?~?~?iE?}9?~?~?~?E?E?~?kB?F?iEG?9?]J?E]D?lW?eD?R?^9?b9?W?k9?bJ?dO?];?R?J?h9?cO?e3?]9?/?9?i9?mF?eJ?J?_O?^3?_GO?i3?e-%?iE?;'%?%?^3C?E?b9?g9?^I?J?9?jE?]J?^A?P?^D?JO?d3?^J?]O@G<9G?]E?<9O?aF6?aBE=>ADA?<DB?@FC@6D=A<BI?F?7AEHI9]?^M6?O?O]?_J6?RB?]=7?O?`<2?,?,3"
"?c9?]%=?D?aO]?]E?h:?H?^9?EH?^X)?`C?]A?5C23?a3,?a3?e,?uU?{J]?mJ?h3?~?dO?hO?c8?j3?e3?<?3?_E?e1?%7?:7N?~?~?~?9?iJ?~?_E?b3?m/?~?kE?~?~?~?_/]?~?~?~?~?~?~?~?dJ]?U?~?aR?,?~?]3?d6?BX?_I?cEH9?`C;?oJ?~?`3?m3?~?n9?}O?J?~?~?eE?bY?~?cE?dY?uJ?k9HE3?E<?,]?`)?9^?E?nR?h,?lU?}E?iJ?]3?~?~?~?~?~?~?z9?%?n[?aE?~?~?~?]J?~"
"?~?jJ?gE]?~?~?n%?k/?d9@B?_CEI@IEJ?9?/?~?~?~?]E?~?~?~?~?~?~?~?bE?~?lE?~?vX?~?~?~?~?gI?c$?~?~?eHB?^U?QO?cJ?R?aR?m3?~?~?~?]N?u9?^L?/]?g3?`E?~?X?_R?~?_C?E?GO?9?DA9?W?cE?_J/9?`O?]9?E?]E?eH=;?B?]9]AS,?F?]H?D8D?@G]C?DO6?`<#3#?jC9O?sH?R?R]?]/?_R?a'?cJ?@?`E?]/?dJ?^3]5?`3?_G?]3?m/?_/?g/9?uU?Y?sE=?mJ?J?]9?E?c,"
"4?bJ?eE?bJ?J?`J?c;?u#?u'2?b;5$?)E?3?`93?^4?~?yJ?i93?`3?nH?/?J?j9?e9?c9?h6?u<?lR?c,?^9?c=9?gA?u;?c3?lO5?a3?b8-?dB?],?c,7,?Q?/<O?ORE94/?b9?mJ?~?m9?^J?z9?9?]9?gO?~?~?u9?3?/?/?]-?{/?m/?oO?dG?]R?_,?d<?c@>8?^&?]:]E?A9?AC9?D?3:&]J9?bE?q9?qJU?a)?U?`)?r)?_3?^01?39]?/?o9?bE?c9?h5?lY?cJ?_3?]/?_3?p/?_,?~?b9?sR?"
"<?aR]?k/?g3?_3?^/1E-EH3?c9?aR?d1?j3R?d9?l)?cG/?a/?m3?a3?@?AD?iB?l)?a9?]R?t7R?aR?bO?z/?`C?u3?b&?J?]9?]3?eD?uHJ?`J8?m5?3?3?^R#5J?43?KU?`:?^C<E?9?i3E?]<?9]?~?p3?lE?_,?=?lH?c9?j,?~?]/?lH?c<E/?=?b9=?gJ=?uMAY?]$?]AGE?]$?^E?d9?aB?cYE?dF9>?;U;Y8J]E?>9;]?9;8?];=>@?e3?pJ?bJ?~?d/?j3?~?~?lE?~?~?~?~?~E?~?~?~?s%?"
"e9?e9?_%?~?vR?g9?cJ?]3?e)?~3?lE9?j,?hE?cE]?U?5J9?R]?A9?]9?s9?~?~?~?~?~?z&?~D?]O?O?]2?J?]9?h0?u;9?^E?/6?c9]E=?`'6BA?E]?];:]E6>;?7=<R+?]6?]84EO?/?iE?^9?]9?~?~?]&?a,?~?o5?lY?cJ?~?~?~?_,?,?~3?_5?;?/-?)?Y?d#?~?c9?~?t3?9?9?~?}3?~?~?~?~?~?~?~?~?~?~?~?w9?~?fY?aO?~?e=E?;?;?]O?c8>5?]E539?Y?uY?aY?~?~?m3?~?/?~?"
"~?p9?mE?~?k9]?t;8?b7E?]9]?3?`9?~?~?~?~?bY?lY?~?~?~?~?q9?u/?~?~?e9?^J?~?9?gO?~?_E?~?y3?~?~?jR?_,?mH;?]5?&?]6?E?C:?b9?uJ?~?~?f)?3]?~?~?~?~?~?~?aO?O?s9?c'?pE?c/?d3?_9?]E?^,'?hE?^8?c/?bJ?3?a3Q?Y?aCYW?J?^Y?`9?^7?/?oJ?_B?3?_,?E?oE?r/?bOE?gE?]JL?J?J?hR?_J?^)?uR?}/]?lJA?aJ?M?]FC?GY9?cF?qJ?a3?3?b3?~?zJ:9?iE?"
"^E?a=.?:3?aJ?/?]3?/?c4]?aE?9?`3?eF/?]B?cY?]E?LR?`JRC5?E9?`;?]:H?<?5?aU&A9?k/?/?`9>B6?]9E?67?H?;?_B/E?a856?0?E?E?G3?A?]<,H/?`/]9?@?:A=<9<]B?=G57?;>?GA98>;@E?H-?O?FL?aE?9?^9?Y?EA?E?@?_X?^E?_E?^EM?^>/B?R?3?EO?_J?]9G?BE]R?]EDCAO:?]E]?dK?B?]9?]B]?@?3?]E?8?/?;K?]E3?3?=A?]EFC8O9O?]C?dO?O?]9?^<EC?4?_9?c9?c7"
"J@?]W?a3?`9?cA32?]9?]>?d=3C?@B9,0BC:?9?_=?g9?_5?9?7?^L?_6?d3?^CO;?^/?E?O?]EJ?`J?]9?OG89?]=?]9]?dG?E?^9^<;B%<9?<5<7LG@]9<A9?;%0=?B:AG<EOIJ?<?d=/J?_/;BR?k9?3?a=9E?a/?l:D;?6?^<?_@8?^C?C?<?/B%@E<32-?]E?_9,?^F?E?9?_A]/?3?^,?_9?_H?c@6L?R?R?]A?^9,?cRB?/=R?]9?^O3?b,%?E?aBJK?_ED3?^=F?K?%?E?`3=LC?`/?h/?]9?B?^"
"1?^UR?lD7E?E?]9ER?^<?]C?e=,:?9?A%B9/?`3]BJA?A;B<@=?<,?]9E9?d1?`Y?_I?=?_9?9?a7?S?F9?^B?^E?^J)?^E]?c9?]E=?2?s/?9?9?_7?,?f3?`5?9O?g=E?]3R?^=AC?=3?];=;?]/?g/1?O?]3?^#?9?9]?h3/?a4'?]/?]9?>0A?E9.0,@?L?3?3?]J]?`GJ?]F?]K?^M?^/?q:?N?Q?^E]?cB?bQ>;C?>?2QC@?^D?]/?<24?]L8'J?2?]:R>9<9<:=A=B;9A5F9E<;=5<DF?A:?FB@J?"
"/]?_B?5?9?ABJ<JC?`E&?aE?^3?aHA;K<?^:E?^C?]=A?d;=?]8E]?>0&?]D8?B?^F?:95;7EJF?E?^BH?a6?3?3?9E?^H?C?<?_9?]O3<?^B?3?aDAH?^R?E?d3?^9H?J?:9;?J?^9?m1A;?3?U?,;6?]EC?C?~?]>7A?^5?;>5?_9?]K?A?P]?^>]@93/?]A92?]<9?DJ?]3?aB]7?8C?JF;O?]9?_I<:/C:5=D=/9/?/?]9?d3?)?)]?^@?^9?]W?B?cU?c9E4?:4?]7-E?]3?^=<?_B9/3AO]?jK?$?a"
"F?2?9?_@?cL?E?],?^4?;?r3@6E9?_E?^9?9?g@A:?9?]W?D?lC9?aY/E?],?]Y?<9?^94@-=C=%/%?]B?3?`I?&9J?a<?D?0?jE?]4?^>?/?/3?b1?^4?dCG9?_AE?lE>D8?;?]WC=:?H@8E6AJ?_;?@A@4>AE/<J<?f:RGN?D=;L9?_J8Y?kE?v=]C?9U?]GE9?b@?3?979E7B3=H?O=?R?_O?_DJ@?D:?J]A3L?E?^5G?O%?`=?_E?];D9E?e;?]E?/?`/?/AD2?^396?b$?8?8?O;?]7:=?O4O?]6&D?"
"]@<?;9?`E?86:=B?<?^=?h91?L-=,;?:C?]<=5@?D?^3/?^J?^,ABEJ2E?]ODJ?]E?^7/?c><?E:A93A>;B?E@=@6@A]=>]?<;A?^9?3?]3?`3]?eU?U?s0?`9?c#?#?d@?9E9?4?2?b,?:?]E]?9]3CJ>?=?_C?H9B?]30?`,?]393J?aE?c9?_3?]9E?u<?3?XW?bX?hE?8?2?f:BO?E?E9?],B?`E?E?~?eL?bR?m6?u5?cL?]97F?]'?`F?^:?<?o3?^;?J?J?^E?~?eH?J?l<?_E?6?;?h3?C?]J?J?"
"^;]Y?`B7?/?JY?`Y?a;?rE?]F?9?9?lE?_J?E?a3?^A?f3].?u>?9?3?_B?l@5?]9?^3?_ET?7?eB5I?^E?]B9?aJB/EA]:?;<G?<WEW?]X?iW?^=?gW?]3?e4?bX?mE?`J?/?l/)?h9J?J?dF?`J?o7?3?E?_R?P?]R?]/?c/H?uG?jJ?8?K?C]?]/@?;3?/?];A?^B?_=?9?a;?^9?^9?_8?_=?E?9;?]=B?<OA?^9H?^9E?^>?2?1HY?B<7=/7?5FB?cE;C8E;9EJA><=E:^7=<=<?]=:>8<?]I<9?A6<"
":C?I?59E?d:'7B]<MC=@?;?R?^E;?cEYA?9?_D6K9?J?]6?_<:?gAD7?6?^:9?^8<?^=?^6<;8]@?/?`9?b3?m9?l9I?bD?mB?u3?`U?]B?]OF:?9?~?]5?3?3]?b3?g/2]C94?R?^E?]>,?]4?dDJH?OJ?JG?_3?_@?F?96GB@:?^9?c9?hD?u9E*?&?c9?_,?_&?'?3O?i,?^$?aJ?q,?`J?aE?l;?uP?9?FW?fJ?dE?j:E?]8?]F9?=?~?~?],?uH?cCJ?f:2?^R?cJ?J?~?~?~8?J?`R?b/?<?c7'9?9"
"?^J5?c5?_9?^BE?qE]@<?9?s=&?a&?_9/?2?e.9?`9]?k34</C?F?^1?9?]E?]49?dNO?]3?]3?`:O?C?e@;89.OJ8:?_<?_<@?S75<]>J?][<?^O?m,?^,?~?i/?bO?q3?c3?]9?`']?J?<9?a9?l,6?^O?~?iGJ?bG?c2O?]J?^<(?l#?kJ?d#?a9?>?c3?c9?.?9?3,J?mB?d2>?5?^9=C76A-EJGJ?_5?^A?pJ?_O?~?mE?l#?^9DR,?{E?~?i-?bO?v/Y]?_O?~?~?~?e/EBJ?u5?~?mE?~?~?e(?~?"
"~?3,?]S?^9L?}J?kJ]?mE?c.?bO?mB5;9]?_>?3<:=RCE?_/?gE?h/9?/?/?bE?mY?u3?qO?,9?z,?~?~?~?~?p,?~?`/?`/<E3?u3?gJ?hE?E?]9?b9?hF?lO?O?O?_3?/?/?_;?-3>3?^B?^/]?],?~?n3?gJ?^Y?~?/?vE?g/?g3?E?t/?t3?^9?_3'?J<7E?W?cJ3?`3?j)?]O?R?~?~?eG3O?jEO6?68?O]80?=E?^9?]Q'2?])?(,?E]?_B9RER]?bR?c9E?^K?c%?%?f6?^0?gHE?I?`E?_4?l3?d"
"J1Z.&<9CB/F?0?J?;E?b:@<?3?_JF?_/?O?E?a9?>AD8?I;9:=@J9F/><F=6A8A>]<8:-8A9'?_9/?9?_<]?bE?E?9?_JE?b;?cD?E^?^<?9?a=&?&?`989]?_E?c3?E?c;3,?_E3I?^.?]3A9?,?a6/<?`1?fE?^J?462?]9?J]9)?e9?`J;E;?hE?dJ7?l8?B?]G?879:?_@?E39?_/9?R?cE?9?<?J?`ROR?^R?^E]J]?H?B?E?mE?E/7=)?_3;?mA>B=6?^5B7:G<C?CB:?L?U5?]:F?C?`9?l=E9?]9"
"?_)9?d9?R?_HJF?;?]J=?`E?R?e=?9?a9?9?9]?^A?9?E]B;7A49?9?]/?^/?9?_EOL?`/@=?O7?]BDJE?`E]?cBO?^/?jO?`H<?/?9?]E?]J/?9?hH?H?9?9?QCR?]YI?KB?bO?3?EOE?mE?^F1E?E]?]C3]?`)]?d>?9FE?_'3?O8O?fJ@:;R;J?E<JF/R:B?FYG.<G]F?@?=@9O9?]OA9?a9?R,?^'?O<B=F?K?]J]0?]R<M?^R?^@O?OM9]3?aE?c<?&?,?E]9/7?]<?oE,3/?]E?/^9]?98?]9?d870"
"9?`9?d9?:?]/?]5:39?7?9?]J?`9?9?E,?]/?E]B<?_E?E6?^@?`,?cE9?`E?9?`R?RE]?^3E@B3?b6=?^3?E9W3?a/(9%?E?^9?_O?]E?eA9?]J?^93?a9?]/?aE7<]?6?^A?_R?]7?K5?a2=:=E=E?=C>:CDC@EA;?9D?;:5:D=;8?;93?FO?cB97?;=?9:]?B?9?9?]<?^9?9?6?dA36?E?^3?_;?^E?dB4@?=E=?aA;?9?R?D?=<9?<=?;O?_LPXE?f.?]/=?u89?aE]F?`V?`,?E?]=?O?;/?g1?c:<"
"@?E?])?`74?AE?]E?|@EB?E3?]DJ9?iE?@3A?L3?^/4?]C?,2?],?bA2<9=9?]8?39?N9?O?C?9?D?0=:=R?]E3R?`%?e2?^FE?f9E?E?U?b98:?a3E&?`E3?aE?]E?R?E?^:?^%?`A?<?E)?]E;QI?J?^REAE?EH?]JE?3?JF?^;/?mE?]3?]ECR1?/?a3?f/?^B?]X?_9?_/?]59?lE?]3?aNRELV?^7?9?b3?hJ?^D9?,?_E?`R?,?m9J?l@O9J?i9?J?a:A.?;?^O9I39BA/F;B?bD;E=?^9?k<?]>9?"
"^E?^@?~?eH<DU?_J?dU?H?]/?A4;?]J?_J?2?a,?dB?b,L?_E?f/?cO?m969?`-?_9?d9?^;8G?=?_46?]DE?BGJ?X?];?I<49RO?n3?]6@9H?;L?]IB?E?^E?,?_L9?];<8:,=V?]/?O?35A?IM?cO=:B?OD;J;5.?]CI;D9C?@B>@:?<;?9?9?_/?c3?~?b9B/9?j9A?bO?mA?3?aNB/?]E?]8/?jO]?lD?9?]9?q/?jE?e5O?aO?`3?OQ7?bH?a/?3?~?eO?O?`9?fO?|EDR?R?^B9?D?3A?B?`R]?]3;"
"?_3?iO?JE?b9?q6?9?^3?s9]?gO?_)Y?N:?;?jE?J?a1/?a9?^J?_R?aE]?dR?`E?`O?O?_:?aE?nA?F?9?]E?_,;,?EH?dJ?r3?3?]E?a:?l7?9?b3?]J?^3?dD]4?^$?K?E?^E?I?J0<WL9;B9AE9?`E?aJHJ?cEB?J?<?_RW?^W?BW?`'?]E]?9?9?^E/?b9J]?^9/?]C6O?O?^6?b3?aO?^9?O?O?_<8?]BK989?]>?O8?^G?`9?j3J?]3;97?^9?O3J3?]3?b3R?^53?_9?]R?^O?]E?e4?-?`9?bLO"
"B2<?WJ/E7G;N?.?G9G<BA?]/?GE53R?R=?]6<?Q?8?^G?^3BA?C?3?A?`<:?Q?EW?]=]?E?9?^<9>O?]EJEGA@=I<J)X?]7<?3?]<7?ABEQL9?EA]B=CGA;AB?FCEB>C>?:@EIECEA@]:9BG4CDE:9?9C?^><>?JEFDA@=Y?Y?=9FDA?];:JH?`RJ?]0@EG?7?,J]3F?3<]?J?eA@GEDE=EB]9EJ><?]7>HF?JB:A?H?]O?_J;XRO?O?]X?]E?E?^989J?@?^9R?^OW?k/?^IO?dJ?^E?]JF?lJ?bJ:CP?;?"
"])G=<?E<C?O?H?J?|;<B?83?]A:E?]J?c3R?^B<AEC3?I?R>?]=?]69?dFE4?5?]EC2:?]3?]N?M?AEC@AG=2?`R?f3?c<E?aE?bE?3?c/3?a1?9?`E?]9?a9@E?a;?^%?%?^=?_9?^/?C?`O39?]9E?]3?e1?g%?`E?]6?^N9?`9?nI?u,;?d3?_BR;RA?O?]BA?a/?3?~?~?e3?b3?f/?a/>?]O9B?/?~?~?~?hB?9?jE?J?J?_8/?bR?R?aE?c3,?aF3?aO?aJ?^:@J?9?hX?J?a8DG3A?)]A?8?X>R?D"
";X?cJ?uG?C?:R7=C9?`E?aRC?]J@9<?NJ3?:?3]?3S3=7?dBEI3CE>79]<?`RJF]GFI9=A=P9?tO?],?s)?s319?|RC?^R?^9?dA?t&39?t9]?fE?h=D3?`E?_J?_96?^J?]9A?cJE?kO?u1?^E?^E?dYO]?aR?bU?dJ?c=?J9?_R>;B?QB?];?]E?3?_9?u)?dE?k9?vO?aH?~?e7?f3]?_3?~R?R?R?q2?cJ9?]R9?~?_H?u@P?f3?hFJ?]L?cR?]R?C?9E;?]<GAE]?`A?bE?^[?aGFA?@?^JE?aJ?aB?"
"w3E?_E?oE?E?cJ9?`9]?`J?^K?u/?wJ?aE?l9?]/?jE?`CB9=?b9?c3';?`-?hO?a9?`+:?^J?_9?d/?^E?]/>0K?UE9?%?_R?]8?5?3?3?9?]AEG?;?3?D><8?IA?D35/?^9]?4=?~?~?xE?`GF?~?~?~?~?~?~?|BE?tP?],]?q;?qA?]'3?b9?e9?`,]4?c<1?^J?]3?`3?~?cO]?gR9?],?~?a9?bC?uA3?aE$?$?3]?`3?aM?lY?cG?]Q?J?bJ?_J]?R?_J.9F9;?^1EB?RJ:?@FJ/?_J]GKG3?jY)J"
"?`E3/?~?m9<?`9?k3?:@9?^JO<?E?aE=JN?`E@E?_/?39C?%W?]9J?S?aJ9?^V?cO]?3E?]3?`E7<?]E?^;?b;?]9?a6<:D?=?037=6?]J]?7?cPB?9?`9]?k:?;A<?G?OA;EA6?L?REC3?W?;J?R?DC<)D?/?B9]'%C3/F8?d=>D:>E?<C?79?IE?AJDAE@A=AC?=?bW?mAEO?O?]J]?mE?n'?cQ?sR?/?e9?h@?q9?^P?^/?qD?Y?_J?n,?lO?O?O?]9?AE?]E?_9?l/?uE?J?t9?]3?^9?mAQ;Z?_2AFX"
"EXR/3?a-?9,FA?_J?J?fJ?`JE?^E?cE?h2?fJ?i59?gE?^E?c;?^J?q4?~?_9?~?`,?g9]?Q?eFJ?J?_O?mY?u>?aJ?cA3?dI?a%?`=?]O9:9?9A?]93<?],?^J?n<?J?J?aE?jDW?t/?~?],?j9?u8?^B?_3?nJ?sN?s']/E]?E?u/?q6?`3?]3?`3]?eG<?a3?d=?c>9<)=)?]:]75<;:?>9?]/?]7?J9JW:?`E?f4?_J?8E?b/?^E?gE?])?)?c)?]3?eL?9?`93?^)E?7?J?^32?&8=?/?_J?~?f6W/?"
"sH?^J?_3?hJ?^J?gJO?,?~?];95?_J?mJ?]O?eI?h=?D?^B?E3]?i26E?g9?_3?]3?{0?s3?9?~?~?~?]E?u<?o/?/?^'?'?eO?a'?u'?aE?J?~?k5F9?`(09?]C/?7?a9?]3<JO?`J?k9J?~?x9?d3?9/?E?D?~?~?k3?o3?/?eE?]O?e/?u:%E?E?]%?n/J?cJ?]E?]E?e;3,?JUY69?8?]7?]E?:9C9<?<76;E?c3?k;?U?9?^L?_H?cE?_0?bW?f'?aD?^9?j3?a8GD?E?_E?F?G?]A?eLI9E?_P?m9?"
"d3?kG6?a3?3?3?3?3?e0?3?a;/?b7?_GE?@=?^3?`,?sO?_3?h$?bO?,?j,?v9/?]7?^E7?^<B?;3?_82?]:N?-?e3?g,:?~?b9?e:$?g/?b;'E83<?E3?i3?cK?bU?lE5?t/?v/EC?`E?]H?HJ?A?eO?_3?t)?qM?uB?2?a#4?`H?5?E?E?]@2:?,?sF?;?b3?9B?^<?]X?J?_9?E?E?3?aE?_E?bE6?,?s3?^E?_/?9?C9?f3=?6?,?3?kR?]9E?E?E?^9<?lF?u2?`,?d9]0)6?9]39]B?;?3?3?7?3?`"
"A3J9E?]73]?E?E?9O?a98?_J?8?92?`E?j7?;?]E?]3;<C,C?3]7?_B?];?:JD,?]3?D>;?BA?A>=:>?DC?7DA/CI9DA?CDA6CLF?K7>?_/?_J?HQ@JGC=CK>?K?]Q8C?9?E?3A?O]?^W?]UKCF?AO?,N?9?]O?]W?eB;ELBK?OBE2/UD7?E?AIA?7?<C<D?E?E]?bE?]3?J?J?iJ?^3E?_3?bG]?,?5?O?O?i,?]3J?^R?^9?b9?e9=M?^)3J)?^J=?W?~?^C?_8A?A7?dJ?`9AD0B2?^A3?]363?D?eG?^"
"I?YE@?CE?=E?^FOBEF4<A8=?1?jE?c6?cB?]J?J?^J?c7?E?E?^/?_E?^<E?a3WC?u>?9?9?]3?gE?a5?uJ?J?`9?`9?g8?J?V?_1?l@E?O?dO?]E?3?C?3L3)?~?~?~?~?~?~?};?=?b:W?O?_J?R?_J?I9R?R?9?8J]OEL?]9JH?R?a@YJ?b:?]B?]E4?cFE?u4B9?9?]7B9?aE?~?^3AJFPQOH8?H?IJUH?^7?RK?],A?BCOE?^E?^N=?h@BD]G;ECB?^RE?E]C<DHA=7=8?zO?~?kR?~?`3?cJ?v/U?~"
"?nJ?aJ?bJ?]O?`O]J?d9?mE?E?g/?_E]?^J?cJ?e,?,?^J?9?kE?cO'?b7J?^U?c3?^9?~?~?nJ?iJ]D?zE?pY?~?~?~?}E?~?dR?]L?5?3?s-?^O?s9?s9?R?J?h9]?a93?h9?]/?J?`9?wL?3?eE?~?`'?cO?c,?9?aH?cJ?cJ]?`J]?t9?O?uLB?R?^9<?g9?_9:=>E:?&J5CAO7E<?C8?`9?9?=@?aD?hJ9?^K?F?O9?]EB3?gO?yD8F?I9?]BQ?eB?PGUEA?~?mY?~?~?~?~?~?`/9?_/7;E?yE?^9?"
"h3]?^</?`31?'?`3?d'8O?]E?h<,$?aI?b9?_E?jB?r';?b,?m;J?a,O?O?`J?mOE?b;?b=M?lR?_J?^)?uC?E?^9?]9?m/?a/?f)?aCB?]9?]J=]CO?D7?CK9/]?]A?]*GDE?^9]>?dDOR?]J?9?C9?a93?~?dL]?b3]?b3?C?:?]0A9,3?8?9]?eB?aO9<0?]E?-'6?]J?E?]93?_C?3?9@]?E?cEBE?)?E?E?]E?]3FB8D;E?]5?E?`8EM,?^3?JR<;B?^3&8E895A?,C4L,O?G?3E,=E;?A/,EJ?d8?C"
"?3@?0;=<=9@,9]:<;QEB)A@;JE89<;?L=>=FJ=O-2=EBG:G])ADK<K?_7<A<@E?D>7>=<@CAB3=]@<AC]>]?<=?9.8?6?QE?]%9?^E1?_9?^@<OK9?^,7<?]9?9,9/?^E?]3?=9?a>9?a19&?b9A:9?`JE?cE?c<LK?_E?@;JENR?;>?dF=3?_'?E?iJ?]9<:?9]/?D2;?];?]E?e8F;?;?/]E/]?`E?e<=?^9?]J^?]9?]=AEO?]9>?3B=A9?9?JQL89?aE?bRE=2H,?_,?^;O?],?<?aRE<O<?R?^K6?kE"
";?^)?^L?d,?cACQ=<Y?]E<=3<=A?C<E?O?KJ?^:9F?9E?]9?d,?_:?]A@?,?/?^EY9?bJ?^R?_A;1?O?dE?]O?d;24?9]?^Y9?]J?_J?_3?8A<C:?`E?cEA?c;C/O9?`3?]7/?E?^/?_39HE?]1?^G?bJ?dH<?,?aEJ?kDC9?B?^H;]?OY<?>A?bF>A9E?jO?cE?E?E]?]@79?E^?g=A73B?95/A3O?BO?gA;B?HBYEBEC?]C<YAMB1FE<B6=>AEO?E?O]?JU?`U]?dEI9?F?]JDA?]DJO?;?Q?9?A?^K>?_"
"'?]E)?c<?c>9H?9?E?lE]?;?E?%?_B?EJQ>?E?O?9?]%?]R>D<?]'?]E?d9?c=/]?a2Y?kIC?fJ?h8L?aE19?`R?>?c<@KA,?5/?:>3?3]?D9?c/9]E?aO?]O]?d9?]B=2J?I?^9A?^C?]9?7/?_Y?]ABQ?B?];CO?^R?^3@>H?J?^9?]AE=J8<C=^>B]A?^;B@G>?>8=8<?.?39KO?c:?3?F?^9<K9JHE?^E]?]F?]C/?`Z?^D;@?@?^B?_P2?ME?dC?@?G?/]I?_GF?9?X?9?DC?B=A@;?;?Y]OX3E?cJ?"
"]5?_O?`JO?hJ?^LA:?aN?9?`J?eBE1?F4?b9?_$?cA;@?6?])D=K?DG9?FE9?E?|;E7?9=?b9?h>@IBA3<O9?C?]A9,07?eE:?:'?]B3?^<=?B?@?C9<H6F=AB?E]9R?]M?]%?i<?^3?^9?_9?]E?U?a9]>4?aAG*?`E8E]?bA;<?B?]J@?_O?_A?B?`O?NJ?b<NPQM?E9J?W?]E?]OL/?`J?eZE?`E]@L?t>H?`/E@?9?_,J?dOE?aE?bJ?FR?b983?<?^9J]?`9E5?_H?^95<,9?_J?_3?6E?d5;?aA<J?"
"bE?`/BJ@<FIC?_2<?`-.@?HE?`;F<?83?:F4CBI:AOC;C?/?`E@>@?=?EOJ?J?bE?K?39?EBDCE?E?^3?~?eMB=)R?^J?dB?H?];?;8>2?J?_J?8?`3?3?3?36?^C/?]9?^-<?^-?_9?c1?bO?mA;4?9?`J?bX?_9?^C?@9@?]9F>7?HGC?EDN?X?];?F95C=?D?3?A?d9?^<@?]:@:BK;-?]@BIKF4W?2?>?_O?]:A7:?<8?D=<H?<4<?]E>?3?^O?O>?K@BD>,D=8HBIAEB9EDB;DC@]=4?^/?#?A?~?eR"
"?bR?mG?b/?m7?3?aK?/?A?^37?~N?^/?qA?E?E?cR?pJ?`3?W]?`E?]J?~?v9?~?qO<9?~?_Q?^/?~?{O%]?]/?^V?cZ?l@?cEP?J3R?]EJ?g3?_Z?_E?g/?u9?cZ?],?R?9E?~?e;?l<?k3?e@K?E?^I3?aH?@F:964HQ<J?u9]?`E?mEJ?t3?~?nJ?p$?^38?c/]?a/?~?JO?aO<?^R?]O]BQ?_J]@7/J?a9H/?/]?FH?d;,E?^9,]?b9E?c,E?N?E?A?9U?R?^9?9?-?^UW?K?L3B:E$XP9?^D?_<7N3B"
"?^M?:=BCE]5?@<G@FAE?<A3>@8AEO8>?B?3?J?]9?_E?^8?_/?O?2?jH?Y]?bI?cJ?lN?k9?`5?96O?uJ9?v9?qO?,?~?~?gO?sJ?]J?e/?]U?dJ?bE?_3?_K?W9'?3GA3?~?mI?uU?~J?R?E?^+?~?9?~?~?~?~?]R?~?nO?]O9A?oR?~?~?x1?~9?p3?c3]?gO?^9?qJ?gER?/?e%?uP?^/?u9?dO?EO?d<BH?^E?E?cO?J?,9;B@C<?]K?_E?dJ?]J?J?^M?]D?l[]?_)]?t9?u9F?aL/9?]R?]E9?_;D"
"?^AJ?`'&?l&=E?IL?9?ED?]EJE9?9?`R?^D3J?aE?^E?]J?9?c;@3?`@?_J?]R?:6?]NJE?<GB?b;?`3]?aJ?^B?f9?iC$B?<?`$?bGO?`$3?E?aJ?d;?c<4H9?`;8N?B]=D=;?E?3?_>?H?J?^E?iF?)98E?aE?c9?dO?u38?fJ]?^J?b<]?]9]?q1?^,?~?iC3?]9?^3?m63?cA?^9?~?_H?uCA?iJ?eH?j7?2?^W?E8GC?bE?lEDS9?`XR?_W?X?dE:?uC?u9?dE?EA?]8>?_9D?^.E?`'8?h3?_J?/?b"
"Y?gR?_3?k9?c3?jR?eE3?],?_A?hO?^<?9?d9>9?gFEW?3?^EI?aE?I?cA;O?L?^8?fE?EJ?]9=FB3DFD/OB?>B@B+IF?cA0?/?]J?]J?i:?/CBE?tO?E?E]?bJ]?gA?X?X?mL?OE?~?R?~?~?~?x5?l3]?t;?3?a,?jKC7B?]&?']9?b'?eI?^&?q@?qJ?]'FJ?a9?_O?_,.?]O?],?6?cE2?]O?];]?`3?^5?u9?]3O?cO?h8?]3?rU?o3]?]E?=O?]E?mJ?^5?^:?uE?cE?hHJ?`J]?_O?gJ953?73?4/"
"=7?6><?HD?cJK:K,?]E?J?f9?J?]R@<?~?mJ?])?i<?_E/C7>C?]B?JO?@E?b=?b;<A?]E?/?<@K?%<?]6L5?a9EB?^E?^E@8?]A?]CE?cF=C?]9?^,9<%?`EB?c<F9?D?^HA?]CF]?AGE?aBF:3H?H?E3?lCABAFH<7O?GBE:9<39EC?_9?_A:CI9E?]5DFW1A:;B<?d@ABD@F8CDA?^G<5DA_DE@?A>@?^'?q9?dW?k</9?3]?]/?m.?bO?mR?c/]?^E?]/?d9%?^3?q-?t=?jE?e,O?sEC?b3?~?dEJ?u"
"%?u4?_Y?^C?E?JE]?=?_E/?]@]?_3?kJ=?y7?4?/?3?oR?q-?E]=?9?`9?dE?c93?tO?u8?b9?l9I?E?a9?j9?L?r3?_E?E?^J?m8?=3]?`3?]3?h<C-?L?$?aRE?P?=&7O?J9,&9?cJ?`J?eEN?hJ?~?zB?iO]?e9?uE?~?~?e:?~?~?eC9Y?]Y?]9?mCRJ%EG?)3D:EAG]E?A?]F?]8?]FO?3?l3?]9?]9?^J?rO?uJO?p/?]9W]?cW?j/93?~W?~?mJ?^9?OE?]E?~?tB/3?3?c3E?gHE8?V?cJ?]E?N?"
"E?]F?O:A?_3R?o:?'?sB4?a3?e9?bF?b;?dJ?c0?gW]?h3?tN?uE?~?eR?bAO?^3?pHO'?~?kCIE?]3?b3?hA:?;9?_>?^GL?^J?J?b/?s56?b3?b3?J?~3?qR?/3O9]?`9?mG?]J?iJ?]J?J?fO?mF?9?e9?_O?b92E?]E?_3?^EX?KJ]?_G?9U?U?aU?iJ?]U7?B?J?^>@?l4C'?9?`J?^3?hAD?D?U]A?O?]E3?G?DIF?E?ADB?~?v/?m)?w3?3?a/?/]?c3?z,?~?^O?v3?cJ?~?y9?_%?~?n1?],?l9"
"?~?~?x3?nE?a3?dR?]3?^R3?d9?a9?b9]?_O?~?c3:3?^3?~?]E?a9?lE?u/?W?hJ?G?3?_)?8?uA?O?MJ?bW?aW?]J?bE?^9?bJ]?dB?^R?zC?^A?_/?9?aB?3?R?h/]?]3?_F?/?`9BYR?k<?fW?h4?^E?p9DKRE?E?]F<?^E/?g=?>?^9?]9]?]K?]9?aT9];B?MQHW?]9?^JE?^:?3?]JE?]8@]AECE]R=3F9?A1EB]A-B<B=9U;<=B@]G9:?=]A@B>;?;A=BJA@:<]?8APAL3/A2]A?BF?^97<U:<C7"
"]8F<?I?9]C1?R?,3?J?^9?9F?^AC9R49?O<F:?]CN?=J?dA<CJEX?^2/RJR9?]69EFRJ:H?=0?c,?a3?e;9?E?iE?cU?u;?E?E?hJ?c2?2?aJ:?]<N?]CJ?J?~O?O?`T?k79]E?E?^9,/?]E?3?e;?<?A3?]E]O]?S?]=?@/:?3;?G:IJ?uE?tQ?b/?m2J?s9W?cRE?b/?~E,?a3E?E?E?~?`J?e3?]E?bO?]E?~?|%?~?iO?EOCF?~?~?~?j5?c3?3?3]?^3?c/?~?`E?g38?]9?]E/?b/?<?J?a:8F?;?]"
"E5?<?)<9?7-]?~2?<?BE,?aE?E?f@?=?9?fE3?dD@AXI39?C?`E?E?;/<?E;GB9B?9?lJ?aM?^'?`W?kC)?]2?^E?c9?c6E?nJ?aNK?bG?]9=?]7?B?O?a7?H?J?jJ?]J^?:?bD?J?k2E5?.?9?oE:6?`9?d98?^=?]7A9?_J?]J?lH?gO?h2?^)?c9?pU?m<L?bI9?]L=?]9[?J?]5?^1?~?m/?aJ?nO;9?9?i6?^=?36@?bK?fR?aZ?^/?cR?aR?e/?pJC?uC?Z?d9JF?WB?bO?sE?y/P?fR?gJE?O?9?^"
"G?_C?]KFG?^JC?;BAM?b9?lG9?]O?^9]?^'J?bB?^9G?c3?c<?`3]?3]?]E?oE?=?9?^/?]J;?J?T?2J?`9?]/F4?a(?dM?c;?uI?u@E?^J?]E?9?kBA?b4,?^3?_'D?`/=3%?e8?aD?J9?]<5,E]F?^,5,?b3/3?3E9?2?=J-5/3-7?F?]R?]2,F5?)?5?34?<>C:8:7:]9AFE@6A=<?^9]?9,=;?_:9.?d9?aA/9?~?mJE;?;G?]E?dE?_9?~?~?~?~?~?~?~?DR?tE9?J?_9]?^9?g97B?c&?a3?]J?A?"
"E?<89?]E?^9?dA?cK?]R?`MHUJE]?E]?_E]?^8?uGR?tAH?J?_R?_E?],?eJ?b9?_J?_OE?`E:]9?`9]3]?gJ?]96R?/]?^H?_J?]R?i3?_J?^6?eJ?9>?:E?=?_3?]E?_=?F?a6?]$=9?]58</BE<9J8?9:?_9@=N9?<?<?K?dJ?_9J]H4?^E?^,?iE?yE1@U3J?gU?_'?@3<B>JG?^K39EJ?J?G?^J?J=?_9?bGC?]J?]9?e9]?`/E3F?`LE?aE?F:?3?E-?]3/?/?)?]'?;D?J?=?]9<9C?</12;=<5AB"
":?]G9OL?]9)G:27;?/R?/=?fE?]'?].B;BJFJR?;D:4J9?R?bC?];=:H3?F1?836?7@;-4>?cO?>C=@?;?=O5;?9;E=:C>@G=:9>;DFQ?^<WEA?A?bOE?`E9]?]A?9?9X]?]E?aE?A?_9]?aDB?c3?9?aG?L3E3?]E?E?]3?_U?cF?cE;?]GF?7?eCB9?e3?d9?^E^?]9?^9?hK?^HBO?L?`9?3J?hCRJ?J9?^ER?b4?^<K?]O=EJ?]O?]E92/?O?`O?aE/?bO?/?]6?h=?@?:;/?G?_;?_3?9?9]?^79L?;"
"?]9]?dJ?J?U]?^=C]?A9,3B6BP?]=67]4O8?%7,<C@E?_8?9?_3?_W?J?^/]FBO?^9?]E?eO3?`EK9?_/?9?b9?e56?E-?^E?`/?^;?,?;3?5%E?D=9?_,?cK?EO?D?^5;?a9?_O9?9?e8E?3?_A,?]3?3?9]?a,]/8?E?`E?E?a,U?E?a@E?b=E?<FC?89E]?`E]683?@3?]B?i,?9?FU@?CJ?p7;?]D?cA?h<]@?I>A?HD1?]C?]H(;CG?;]6:B@?,]?^J9?bL?bY?]E?D?J?b9?`9?X?J9?^8?9?a)?^E"
"?d9?9E;L,?`O?bO?]J?f9?_09,?G?2?(?J?b;?^E?&?jEH?]O9,?]D?^9=B?]9?]U9?aY?]C?O?b9?]9?]J?eC5-?,?^39J?`8389<?3?]69B?^3?3?hL?R?c/?q<?^R?cO?_1?a9?=5E?5?]2B?_B?]E1;9?9R?_A<C^3?:/:=?DA?;=@H?OCD:?5;BCF?O?R(@?_/?a/?15J=IEDH?Q?fE?dEI,D?^/?aG?]J?eB6F?`A3&?]A5?B?I?H?7;?8:?]E?h3?J?gE?h3?c:?E?9?R?kR?,?E?^=?^9?m5:B?3"
"?)?])6?]J<?N?~?]>E/?^3?]E3?kCA9D?gA?eDO=?/?^C;?^:?_EJ5OB8E=<@E>?</]?D,?R?B/?W?E?_E?^DJE?aBX?9E9?]R9?c<7A?3]?]3,?^1/?/>N?`,1BCEKE?_G?R9?9]?O?3?]E]?_>E9?9?_,9]J=9?`E?],?^;?A9]?aR?aH?b>O?G?`A?_R9?gGEN?E?_ED?]I?]O?eJ?O_?]9?_F?_E?E?]E]?F@C?]1?/?aO?]P?-9&?aE?E?9?b9?_R9?8?](?^@?u><9?9?]J9?`9?^3?E?a=BK?F?E]"
"@;E?MDA?>:?EJ?].?D/=<J?_J1?]R?aO?JR?K?>;A/?`OBM?~?dD=A?]U?]8?9?f9=?JF;>J?a'?J?O?_G?@?E9?J?<?E?E?^3?]O?9?_K?_E?^VYE?E?^9?i9?]/D<?E?_E?dB?]EH?^E<>IA?^9A,:?EB?]BA?`E?B<]GJ?J?^8?h9?^BFB]?<?^H3?I?K?dG?],AFBJ8?]EC<GE?CE?@B/?c@AD>;A89A>:EI9C?CB@:D9C=9>;.?E?uU?eJ?h/?`R?oJ?E?sAJ9?9?_E?H?E?]3?d3E?E?r9M?E?s<?g"
"X?l,?h;?^E?^,?~?nG?cJ?iJ?J5?u7?3?`1;E?]7B9?B?`,?],>?.?rJ,]?a,?~?eL?l4?E?_E,<?l3?9?aM?^9?^9%/]?j/?uU?n9?c/?6?qE?u,?^)?_3?lE?u@3?],?E?^9?aJ@;C?C?];-<?9?sB?gW?]<?e.?`R?R?~?c/]?fE?j,?E?`R?mJ?^E?aE?R]?~?_I?jJ?A?L?J?]3?DE>3A/?^A03?8?a9?9?_E?b(?J?]9?a>?9J?/]=?9OJ?a+?3?_E?;?3EY?'BA</B=?]7J'?^,?3B9G=,;9?]1@9"
"?];AC9@:8<=>;=A=>EF?3=?85:A;O;?U?:?dEWDOF8YK:F?A?B?^9?]E?H?dB?`E?E]?cC?gB9DMGJ?]A?_;-?^A?G?]G?43:?u0?c%?l=?J?9?`J?bY]?`J^?O?tAE?E?dJ?~?_6?`-3?3?3?3?,?e3]J7?a%4U?9?hO7E?M?E?B3?O373?^8?<?8>,D3=9]?=?`#?g9?k9J?g6=8?3?^>?b<?9?_3?^O?uD?`O?_9?<:?h4?k9?k9?`9?g3?u9?j4?3?E?E]?~?~?~?~?~?~?~?D?A?aJBW?Q?_E?cD?b3"
"?]O?O?]9?E?mE?]R?g/?~?^9?76?~?`3MEY?]9(HJ?E?_J?`F?],@?u=69J9?^BH?OEJ?]E?]FA?J:?=5CE?aEJ?cO?g<E?bE?_O?E?~E?`E?mI?/?/?_G?^6?c-/?J?O?q9?^<?^/?u/]?b9?h<J?bO?c/O;?E?]9?CB?b93?o,?`/?a/?b9?M?O?E?b9?9?b,?3?^9?kD?c9J9Z2?_3AMBE;'D1?]9?]4?9?FE?mJ?J?^3D?_9?p3?fJ]?h=7?^9?]E?h69R]C?^OJ?q/]?]E?`/?~?kE?tE]/?]%0?]U?"
"eHE?J?~?jC?aJ?]/?`93?d9,:?;?^,?_J?],]E:?^;?=K]?],?`J?lN?K?M?aE?E?aE?]9?^B?9?9?_J?h9?^0?E?]E?pR?B?aC=,?<;?]/?J?]+<?^4?u=?9?B?_@?aE?bY]?^L?b9?`G?cY?O;?]/?hJ?E?J?]9E<E?b93?a3?dJ?R?8?f3?J?_/?^F?O?a9?c,]?b7:?G:@?,C?_3?]:,E?]9?`<58@DFJ9;768A]<8D5E?A?4,?^>AEJD?]3/?eJ^G@?*JD3>?`E&3?k3?uF69U<UJ?<&?eF?B:&,?_O"
"J?~?~?~?~?pJ?mJ?{O?O?mO/<E=E9?9?c9?b3]6?^9E?]9?^E3?3O?^E?O?^E?_;3?aB?_9?]W?,?'?'<?'?CGE]/?f,J^3?_J?JQ?]E?_<BKOG8?3'?_/2?^H?JE?i,?_9?]/:/H?H?^/?b/?aJ?^7?]E?dJ?]3J?dE/?a/?@?`F/A?FE]F?3;5?^4?/?^9?]D?^9B,&?&?/]?`5?^O?]3?3?]9?/?cE3E?E?^>?d,?a'/B;A?=?]JF?b,JD?9?`37J9?:9?]I0=?=A79=:K?C?]/?]J<=B?>59J;?d,?@?"
"EH?]@8?c4?^3?~?`C-:?6U?]B54?bA?A?].9;A60B67E?]OH,J?H?]@,A<]?97?O?D,?]@?]'9E/@379?9?A9?]B?^EB-?]7?^FJ=?]A?d:J=;>%A@7E?]%?_N?]3,9?<3?6?DC<7=@<9]8:@86C?=?<3<9E?F?3A?>78R43?]F?dJ?7?]3JA]=@>T?&43B><]E9?92-?BG?GB?]K=D=J:]E6<@]A7=:?839EC?_;E=;=<]B@6;?>C;=9]85;8>?];]<8?=A@=@>]A:<@:@]EI@C>A9=5D=>?g'?/?~?WO?="
"E?>:9B;A03AG;3BL=O@?aBF6<28FB@A?]9?>2J?]RE?],?D?:?hEH?]I?bO<A>9<]C@ED/?=?<?_M=J<@27JB?hB/?b5?]598AG<=]L8E,?9:D?^R?E?3?^L?:=]78;<AB?]E<73?]1?9]3?9TUB?g%K?~?_=0A?69HFG@,?^8?,?3?c#?]A6=?1?R?]/?B9?]I?_E?^9?9?J?J?9?`BJ?]D?E?`O</LD2;,:EB?_M?d9?]=?h7/?`3?*?1?],M3?:JSO=?e,?],?,?;CA^<=FCE?E])<)JE?]9?]L?AJF?h"
"@?~?]Y?3O:2D;9KRB?_@?]E?d0RJ0+A.?3C?]R]B?^R?nJ?L?_S?bOGM?=7>7H5D?_[?_R?]RJ?^E?]E?]E3]?^9?B/?b:?]3<?=?L,?G?@?_E?^9?O?]5?]D;@]ACB>?>?7BAIAO@J>A@S4A?LIA?g(@%?~?'J9>@]:B:@5>6JCH?JD?@D?]&?,Y?:2<C9B87H=6?23?)3?5+BA?&?97:?^9H3?^J?^H<?]9?a'?D<@?CAD>]A2?7?H?_7BCDL?H>C?hA?aA?R?]E]<?ADI2GB@?]D?:9?^L?];7,?H8:;@"
"IE?2;A<9?R9?E9/)<?JI?]O<';?(=7W?]%]?]C?`,?JA?^H?t9;G-FHDL5=D?^QC?f3/?JD3B3?16?`>?]BR]?]7?]NA?]9?]J?]5?_=A?],L?^=,?E:?]C?D3$]9?_G?`/J?J?^W?9E?4?W?C?]9?A?bJ;?]1@:?^FBE5E?^OD?f3<9D<4<;>3H3?EJ9?`>?]H?9OG?gJI%?~?]JB?]9&8]?D]?_H?gJ?_DC?]W?]E?E3?]A?q4?^K?_<?]L9<H4D,?:;E?_J?_R?^E?^F?/E?R?^@?^J@%?]6?BU?O?]Z:"
"3]?;Y?JM@?`3?]A?_J?]MC><>?]@:?<]+=2<5I?=F=<>@34/=?gWE3?~?VY=B>=@<@;:=F;<5:?9?2KG?a6B<?7>;:L51?^F6CRF?:?`EC?e<?]9]?],?c=@>=>@HC];:?]$D?XR?H:3:>?63>?aEJ5?^W:?_3?^E?]A5L;BGA5E]<S=;EDG?]XGK?JI?JU>EB:@6JIB]?]@E6/?]6J9?_3?E?h<3?~?3Y5BJ5D9C9?R,?^8?^9?c3J?J3>1C?%?_;0?]3?_=?]J?]9O?>?^,?);?D#?]/?_H?3Y=?E?]9:X"
"F]?_3?g5?hD1?]A?_3?^J?_'?];9?e9?]<?]J9D=BL=C4>9T?B?B/3?5A?E9OE,?E?hCE?gW?B'?]VGA?]R?6?3?=Y?Y?`;?:?YEY?J9?3O?'?^3?c7D?]9]I?<8?_BJ?d/?:?9E';?^J?_>L3?B?E?a<7]QH:A61:?_OJ?d-?;?E?]H?]3?1?^D9?RA?_R?]=A?93?HMJ];,?,?<0?]F?_<?]@?=A?@>?<;?=)=;>]B<=A<D]@R=C@?g;B?~?_8E5=@=?>]@A9=-<FJ7]:7?_:E<67A<]@<0A?/<JBF?/DJ"
"9?]7?]9C?d93A?B29?G?a958>CA@;B>A;L?^@E]?^D?HJR7EB?g9@?b/:?E,BA8<?A8;:BMX9?=?^;=4?3>?9L;<)9BD9+UA?^9?^J:E-?a8?g%E%?~?^E39?JB;]?C?_E?^9?a3]?]/?a9?_G8?b)?]:=?3?_<?8?_>E)?2J?J?]J?C6?_E?]9]?_R?`%?a9?h/%?`3?`:?X?]2E=;7?iJ?2<><A@=>=<@9-?<=?9?=98?>B?^A?g,A?~?_:@7?]<=G&F?]/?7?gAE9EB@G:9C?^RB?^J?mE?^E?^J?aE]="
"]D@B?:^>?%O/:?]%J?_<?]9=?]=?MR?bAR?]9?^B7?]5=E4A?<?KFA,?^C?9?AO?^F?]E9=>]B]?]@?8D=E=@6G:<=]<@;=A=?g=@:?~?]9<:=B]@B<]:9B?D>I9<];<E8?-EF=8<]BCA>=A=?<B<8>G7A@FD9?9:<?^HDC?b<=>?9?_=?;?5<;>AB@]AC;E7D@O9I@>?;,>J:>=?g4?:?_MERE?HGE=A=IFDA5=:2;F@?'?B,<EY@/H<>@>]A=><:A7?=9=;6EA<=F9BHB:?]BF@]BECAKEDC@;</?@A9ID"
"?CHA?s6A<;<]?>]:=A8EAC:;89<@7EH>O'6:>BC?<]F>?BGE?CB;8DB^EC?BA]EB;H<:9?8B>A=D<D?@?EC4D8><A<@AH@=D:@MR=G]?3RC[:?JHJOBDB@FA?C:@I7/@A@<D<=BAH@?]D=<D=;:@=DB]?^D<I?^EC@?=8<^=@A]@B@C]?]AIB?_LBCH?BOB=?gAD?~?eF?]>?]4?>?^:?_>?^:,7C&98?];E)<7C>=?B?_6?c=9?`E=D8H?H?^<@?^A@JFL>9>;B?^JHE?]CJ<E]?3?JB5:6REIE<E*?3;?4"
"3?6:7KO;?R:=?>97@OIDG,?4?=:<?<5F?JE?<C:>;?>@?]<?AU@;:GB?;C<E3C?>B@?hC?~?]G?;]><5<=:E>G?C=^?]DR&?D?]JFA@0FH=DL<:?^1>C?]/39]?^<?A?d9?,?]7?]5?c:EA>]A@C9<E9@$:4F?75:B;]E1B@?aJ?;?_@?^D3?^<?3;C8:=B59E?<O;65B);?E?F?MD?J6AI<,JG?^C?J?9E?^;E?b5?h/?~?`L7,?<9?]3?_9?^JE?b3?/?]G?R?O?_86?`3?`E?zI?R?Q?_R?`%?a/?h<?a"
"3?^R3E?v=C@IA7/B>U?]O:?_J?]OB?]9B?hH?hO?]J9?Y?C?^9A?Y?_YJ?_B?E9?FI?F/?3?36?^9?e9?7:UE?^:?NACJ?D?c5O5?aDOC,E<:Y?IOEYL?_BJE8>]A3B5?_B?`9?]J?]GB5,KEGFA;A?^1=D?3F359Z:?=?BL]8H<:U6E?2?3<:J?]DEFMCH@<;A?<A>B>?@=9A@>:],>A]U<AB]@]?hF?~?]B?;?=;@B=]<C?]9F<95,42?]9?^9=<AFC<D?F=A?IDC1J?@0E&?C?^A?g9;RO?C?aE?>9AI?"
">?=>@D?GCA9?^=@E4FGQ8B?gEFH?^E=JE6?]K;G<FA=MB=B3?E?;E?]G?AO?9O38<@=A]=A=@AE?E?=?@?<E?QEA?B?A?hD?~?]R?=A=9C?D<C?`AE?]A?/Y?4YO?C9<I2<8?]B/?^E8?]7R?]E<?^;?A?`,1?_AI;?G?_E?],<=?G7]X?@A?_=?`O?aF?g9@9?^9?^3?^9^ED;E;6=?h4?,?<ADUS=)<E:9?Q?F?cC3E?j9?~?]Y]9?_E]?]9?]Y?E?g,?]&AFC?9L?_BL?3?oJ?]C?fYOJ?EC;?3B;?^J?"
"J?bE?^9?]JAE?_3]?]H:?3?_UK?]9@?]O?E?c@D?]U?bF6@?B>?B@?>;9A?><J?;=>);B?C7D?g7B?~?_;9?=:BD@=]H;DL><C9B9=E8F?YICF@D8A?;DH?]83<G1?9.GC]8?IU<?^3C?_J?]J:B?]B?_9?^>CB?D@9H@B,?X3=8:?]7:?]9?A^?hC?_ER?]I?]F>=8M2DA59AJE]B=?cO?M:@]>:O@<5G=3?^;E/?;)?`/?D/?]%:?3?E?%?];?3?`%?]E?<?u63F9JI<?=?^E?;6?]3?c<2F1)8G6CA98]"
">BA06;?]L3>?JCAH2R<=B976JEIA<?#?D?_8JL:@?E9?O8?47?fJ?E?J?G/?H?:?_/%9?<?1?]/R:%4?9DA?]E9?]G)C?_I?aD3:?0:<5RB?;?3?69?^H?a3?B?E?9?~?mO?^,-?^5?]Y?O?g,?~?]J?,8J?fB2RG?J?]EB9?^J?c3?^E?xO,/?^7?J?]8?fHFA?@?]><?<BA_=BC=E@:HC69>@?hAE?~?AC=A@C>:=]>;@C?DA?R3@BF9D>59/>A]=]AH5:8R9B6?A%O>C]LW;?8?>?e81586,?8?aJD?D;"
"@ACB;<=B9A9@7FQ?D>;EB]:5@?a5;9?^CI?^@?^@E?]ABEB]@=A<]:=7=EBC9?E@A?@G7;EA@=>]:;=<=1:</A;6;?]=?_5?<?~?k=?:=74@<B2D@39A?<39J>?_:?395?D@579F/>I?7BD;3?8RJ?AB?]DAIGC9]B,58D2G,@D/?BSJ?KH?BI?`@?]7?`C?`J?]C?^@?bD@?_=?A?>?9?6]?AF:R;G?B?XE]?cH9AUA<?F?;>@]A=D=@]B8A<?DE5<FA?G=9EBA?gHA<?h8;9<;=;=]E=;<65?:3:9B?O;B"
"=B<=:=C6A>#?C/:<3]50A,J:,7?6:CA:<]CA>9=;A^?EA?a:5B<8>D5>=:?<6<:A@=?]G=O9AB<B=B^C=A>@]=9FWDG5/@E=9FBE;BC9B;E]>5CB?:9@<AJE:<=@:=?AB:?;<8>@>A];<`9?;]96C:F?;:?v>?cB?~<?c@7?t<A?bO?lB?lD?c>?G?s<?c9?lA?<?j/?cB9?bJ?uE?l4?l3?cI<?^J?oJR]?~?c8?c;7O?s;?z,?p;?E?j3?cJ?cJ?~9?cB/F?zR?nB?u5?B?_3?`3?qF?l,?,?s=?]N?`A?"
"f9?`@?]G?]3?`7?]7?]@?c<?]<?`B?]U?]/?]<?`>?U@7?J?`>[?kBO?]/?U?]<?]J?`C?c9?]E?`C?c5?cA?4)?J?^C?h#?^@?c:?)0?`B?c=?O?]E?^A?/?`O?aR?J>.?M?`=8?eN?a/?cE?0?/?^2?c,?]W?`5?fE?9?^:?^ER?^B8E?3]?b3?^J=?aR?GE?]J?]E]AE?aR?m)?^O?_A+/?]B?^10E?]/?gD?_9?^2R1?HU?^E?c,?_/?^C?/?hHJ>?_3?^@?E?a3?bL6?c;?aE?^=?aR?cD?iJ?ERA?b"
"E?3?jAF?fL?~E?_C?A?]J?^B?8?,?^93?^9#?]J?]J?cU?.#?`/?jH?_,?dH?-@?`0?cE?]=?cB?`B?]B?]@)?_<?]O?])?]=?]J?]7?]>?fG?]F?]<I?_U3?c[?:?c@/?`9?_,3?_<O?]/?_>?c;?cCU?_N?]=?F?^3?f@?#?aE?`9?]H?c:?c<?/)?_O:?cB?`3?]@?aJ?J?^2?_>9?b,?f39?_:?cH?dA?bB?_9?^:<?`3?J?^3?][E<F?]E?^R?g6P?_6?aR?]4?cO?c)?`[P,?<?j8J?s9?d<?8?r2@"
"?O?^1?c0?]@?F?aR?`'?c9E?H?eO?aL?e9?^NO?=OS?_<?eL9N?_O?R?aO?`36?^:O?b:?aE?9?cKL,?_)6C?a,9?_3?^K<9F?_J]?dU?b/?d@?_,?^=?9?,?_7?9?9]?]4?d>?c@?c=?c>?]<7?_>?c=?l=?`=?.C=?cE?bA?c:N?b@]?8E?_7?c>?cB?cAB?_5G?=?D?aD?J?a6?cC?c@?,H?$?^A?D?a=?c@?cH?6?^B?,E:?bD:?c3?b<1?b96?1?`1E?b93?b:9?bB=?_9-?/E?E?`A;J.?9?^4E?bR"
"?]J?`@D?JF9?^,?dU?b9?^[?_4A?J?^B?Q8?b<:?^0?^HE?b:D?^=?^E?]02A?g>?d9?bKW?]3J'E,=?X?_3?B?l<?c=?A<?`<?1?aA?c@?J?aD/D?^D3JD/E?]E?^:?=?_C?E?c5?a9?=G'?U?E3?J?cJ?a[?E?c>83?^@?]C?G?a8?4?_E?E?J?a=?<?^J9?<?AL9+/?]:3?_I?]7?D?a0?cH3J?^P?'@?];?`@?]93?;?]9?]A?_A=?]7?]:?]>?^@?@?]=?`B?9>?]:?`A?]<3?:?]=?]@?_<A:?=%?_"
"@=?@;?8?]<E?/?_4<B?=%?70?=@?>?]@E?;J?_:?]A<?<?`@C?@D?@?];D?9;?@<:A?:D?7?^C?97<9G?]:?]3?3?`24?E2?9<?=B@;?]9@?9?^C?@6?53?@?^C?=A]7?]O?]2A?@]?>A9?]B<D?^=CEA?5?]:I?U-7;?B@=?@?;]3?=>D?@=>0<;:?E?]G?IE<?:6AO3?A@B@FH3?]<B?A?A@=<>@I7?D?BIA=AN?<HC7;H9?5<@=]:ACE=<9HC?;^DC=CE?A6G2?8@A@9@FDCE:E@>A6AFV?7@=7:D@:C@"
"D;B#I=/?G<9G3;]J?;:D?]H9/?0<A73:6F?=]<79CB:;@]>:9?_A=B]0P<?^D;=3@B,?V=B;1@>7=?^C;?D?]I?]B$@]<7GB?=?^E?<=?>J?9:?@=?>CG@D8FA?8?^C3F;?B=?:?^D?BGJGE?<A?;E?9A4?<;@J?<?]HFA=?B]J?A?b96E=]R(?4>D>;?IA;?A?59=?^OJ;P3AJ?_D>?^VL?]86W@6AXDB=D?C-)3RE=C?<JB4E]CB?4?]9?]1D];%?4>:7=7>C@]=C;AE:?_Z@D?5P?J?]E@<C?F8J?D>?>"
"?D=>R:A?`A?]>?^;?>?]<?]@?]=?]=?`=?]A?]>B?B?]@?]D?]A?H?^9?]=?]@?^3?O?`<?_@<%?_=<?E,?]G?E;?]Q?B?]8C?=A?_<B?D?];B?DF?;:?_;IS=3?<?`;H?]3?_A]?_BAB@?6?^H?3A?^P?E?B=?A?^>?,@?@?^A?:F?:EC:<?@]?A?^F?H;?DE?]3?3<?E]?`>?@5?]B?=B@?_97?9D?]9?OK?<]?H9?@;?@A?_@A?;F9AB9;8=AF?_E=?;E?]E?FH?;=?],9,?]<;?O4.=>;C:?_3QR?:?]"
"A?^'EF?]3?]5=03?_4=K=@?EA13<E=FJ?3?7C=9AO?R?_@=?]DH?]JD@?O/:]CB?HE?^/;O?_C?_.H?]9?<5?E9?_E?GK:9?@D?]=?E?a<96)?C?^I,?^JC?],7;J?JE7@<?]L/?]<9C>?6?N?CI@BJC<?]BY<A?=?^=TAB?@AEDA=?B=>?^<FBA?AE?]6ZJ9?3?^=?,A7@.?]@?@:OH?_EJR?^7?]:@EP=?J?OAEJH;?^:AB=?<=@YD<;@?D?%?:A=.?=?9?]MB4?^1?^J?MD?4?B=]9=?^EG>9DH3?<?I<"
"@:=B?@57>=].4?9?=;<AKA;=>C:<>AL?^=D:A@6R:9GH2?BA?-9?^AFAOF6C<:>?c>?c@?c@?cA?]AP?h@?rA?F@:?bH?c93?b@?c6G?;R?_>?c;?c<:?b=R?_5Z?:?A?a=?e9?j<?<I?6?^<?cD?0?aF?c=?>?^E?9@&?^J?g;?c=?c:]O93J?^>3?bB?cAL?bA=?_A?];6?b93?bEJ?^9?^G9?b53J.W?_M?c@B?3?E?^D?J5?`B=?O?]1RE9]O?_9?9?cCA?^:?^4?_#?^@JF=?`9?cH?_E?^3?cAW69?"
"J?])8?D?cJ?a:?D?aE?J?a<?@D?Q?^D?E?aB?L?aL?9?aD?G?^L?]-?F?a6?9?aA?D?_M?@?c3?'WR9?3J?]E?aD?9?_@?e9?`M<KN?9?^9?]I?9?a<3B?^PD?^)?aJ?<?]<3?]E?b#,?>?^4?]R?c>?:?^3E7=?]=?`B?]@?]>?]@?]@?_C>?]A?]D?a>?A?]>?]/?_J@?]A?`>?]=6?:?]=?];?]@?;=G?6K?_A<?]R?_=?]8;?^.C:?J]?9?]@>?<@?I?]A8?_9?]>=?<C?_><?86?_8D?A=?9D;B?Y@?"
"A?`-F?;<?]9?R9?C?]7A?J?^B?]<?=<^?^B?6?`J@?=B?<?^B?DC+4?^:?>9?8B?<?2?B:EO?]<;3<B%B?]@H?:=5?]0=<?H4$9?]=]F>=?O?]DJ?@R?_=@?@<)?^<@AB;7?^;=?<?A=98D?A7E@?9?C<@GA@?I=9J54=A?]A=G>7L5,ED<=8;DB/H8><]?_DQAJPA]B?]E@2=@D:?^<=3:AC]?AC6/?48?^8A-/9=?]3,?^=D?]GP@?];1?]E>91;A]?]IJ?^3?^M3B6C<=?^=9?DA<?]YAB?:CB@%=<?>E"
"?G?^A?B=?C6?E]?9/?2?]DB?8]?5?]9B?BAB@/OIC?@R?^ER>?<>?<?^=?79?A?^BE8BAF=E<?96N/B?^P?6A?I?]E?c;ETH?5?^:G4CFB>?83R?^R?]:38?E96?a8?A?_3ED?@?]9=:?DJ,-?^8?8?AH?]J?]D?W?^=D/<?`,9?=C<;/CO>?@?3?]69M?KJ2@?^@37GA:?]J@?=J9A9L<=?`B?]E?^=?=?]=?]B?]E?K?aC?]A?^B?>?]=?]C?]A?K@?]C?]F?]A?];E?_@?]=?_>=D?_:G?D?`J]?;D?7?"
"]GEBH]?_K>?>L?=@?<>?;A?]/?<G<?L?LE?I9?=E?:=?_BA?>E?<C=]?D?^@?YB?9?J?O?]=?@E?]>?C<?B?^A?]C?9>CBD?B=?:>?]>?:B?<F?N@?YC?4C?`A?>=?9@?]>:?]5?C:?;A?8B?`;?B7GY=]B<?_AD?<B?=>J9D?:<?9B?6]3@]?D>?3D?=E?;8J?^A?]98E;=79;?,A9PJU<J?]L?]E?:B?9;93J;:I?]9?.3?@]?@D,?@9>:A3:?]F89C:@FDYI?<C9?>#?^A@FAC;]=>B=C?5?3B?`HE?^7"
"A=3=?];<-=J?:?3?]G>'9A<G&<?>?]E?]1(8A]J:@,?VI@E/C4?_>B?]=5B=]?E:?]>A<C?5B;?)FQ?;AH?]9?<9?A/?JC<GB?<>A]<]?=<>K?]>57>?AC?K>C?B?D74?8?]A:@?BN>A>:<CN7?[A5C?9OM?]D5B7D3B?JBCA;<?^NB.AC;G?AM?>:@CR(?K;=AF=8A?JGD>C@?=?E?]AFBD=BD<:?5>?5;G:>CE5=@A?AH=<A5F:0B?=]E9]D7;:=GAD=;D>:=]@(G?G8=D;=D:69A@?G<F=>7?L?BC@8:C"
";:?~?~?~?^<?d9?>AL82'?]8<I3=3,?d@86<3?D?]>?2JK;D92?~?@L?:KD3C2>HE9?]A?JA?dE?ARKAJ5>?EFWK@2=?~?~?~?dO?]=C8>?=A>9?A<=]@><;@?c<98@<E>;@?7?=B>;:=?v@?]O?`<?<]A<>@A?^=:=]:@?a7?^=7A=>?:<?C;B;@><]?~?~?~?aG?aB:@A]<>B?F@?AD=@A>?`/?^>?@>DA@DAB>@=>A]=?v>?eFBADA?<AED@=C=8A>?]/?aB=@CB@=@AF:=D?]A?~?~?~?k,?`G?a/?eO"
"?],?~?~?gO?^/?~?~?~?f>?],?`>=<=?=@;<@]7:?AE:>:?c<>6;>=><?BG<>A:?=;?v<?],?`@E7;:7D;:@C9;@:?<]A?cAE5:B>C7;@C>;>A8@:?~?~?~?^<?c=A6:=A=>=?:9ACB;6>9?c=82;BJ?B8@GE]3>?9>?vJ?c=<&>@4?@;@?]E=H:]BF?cBJE;C]@89=B;A]<>H:?~?~?~?gO?j/?~?~?^/?`R?f7?_O?dR?~?~?~?`8?cAB;@C6=A=<94=DFC;]3?c>?]D;C96A]XB?B=@J=?vD?c>87>@E9"
"@JALE?F<C4<A?dEDC?G<]:@G=@A?C<A?~?~?~?^=?c>@:ED=C=@=H9;CGD@<A?`R?]=E;?B]C]=]F9:DB]FD?vD?c;B6?CA@C=AG?^ABA@]?`R?]>G>8?C]<?]B@>ABA@?~?~?~?~?~?x3?~?~?~?~?b9?cC?/=J?B]:BI3A;A@6;L?d3?E]58=4?^<D@B]6?v8?c93G>I:?>4>,?8;<E@]E?c=?DEG;E]HB?KJ8>GF:?~?~?~?gAI9@C>9CAFO:]TDHB@H?d,?CEKL:CEH?]E]GB]?~?7?]G]BXA:BH7GEI"
"F?A?dC?ECKCG-=F?OBDB]9;?~?~?~?~?~?w3?~?~?~?~?bA?dJB?CBCA>ACD=@CDCAK?cAI<:FB@CA]GH@B>CB?w3?c<E=>FA;B>]E>BKB]C?R?c=G=BGA?A?CKC];>?C<?~?~?~?^I?c=;@?@]DB>AT6CA]CO>?d:;]@KEF5?=EJ=;?];<?vK?cBD]ABFB@?=EJ3;>DE@W?c;8<>;DAI?D]CANA]B?~?~?~?~?~?x3?~?~?~?~?b2?c>B<;A^=]>C@>B]=;?C?c@>9;B]@=>?A>@]?C7@?~?;=5<C<6=@]:"
"B]5?C9;J?c:E:7AC<?=]-=8I;<@:?~?~?~?^3?]/?]/?]<6:]C=;]:@BC6O:@<=?d:@3<C?498]?I:E;AI;?v9?J?]J?]J:B;=B?J78ABC9;AFI<2?c<F@]CA<@=A9?HB<@E<?~?~?~?~?oJ?~?~?~?~?~?s8/?<BD;<:]9?6@Q:]2?d<G57=?759F?]&D=6;7?v6?c8?56<;?9]?]R2;D;39?d7D/5=<D:*=E5E<:>@;?~?~?~?^8?c<3?7D84@F@:?969]C6E?eR9>=EBCD7J?J?]C5?v2?f<H;B>:>?JE"
"JA9I9E?c;K5>CH=]C:O?;C<@?4?~?~?~?~?oJ?~?~?~?~?~?jL?c=?D=B86A<A>8A@>=]:D3?]3?]3?<:;7A5E<BDB;4FGA?;?~?E5?=B5CB9DK=JE]B?;K?]O?]O?]>;<>ABGC/BCHCDC]A;?~?~?~?^3?c@AQAC>FB5D]9BA>G:<?d=<D:BE<?HCIAH>@A]:?v;?c>@=:>G=?>]E?>?@B;<K?c@>:A>C?;<?B<]A]B<=?~?~?~?~?oJ?~?~?~?~?~?j'?c9:]<><=]0BAF=>5@:C2?cA49:>9J@C<:];?>"
"=8;?~?@49?ABA>CDC]8?H=835?c<H*;?/:=<@=C9?<?=]?~?~?~?^,?c;]2>A:;?CA@6>]<]=6J?c@]9<?;<;3A]9B@<@<8?v2?c=67;?;=@;=B5><:D;8=?c<:;:<;A:=?;4:?=?<;?:C=:8AFD?<;7>9CAC>CA:;=FE@?9@<?=CAD>A<>FAB^ACB8GEA;B?=E:9<A@?=<;=<CE96@B<_?<7?5I;@F:]H<0;?B5C38>FD>?FD8B=78:?9AR:?9@=@?A@A=>A9CBF?:?:9<;U=L?>=H6@K?]A=9BE8C@8B?5"
"IC6DC7>@:7:;F?8?BCM:EJ?I<?DC@?1B)CA;E=<E8:F?6A?<?G3>@FG=D,CE?@=?7D>E;:?>D=<=@?>?BAH?@>LM?C]=C=BFA?=A4B=GF;<C9?^>DE:;B;ADA9J@E@?9?:A)@=8>2L8:/A;B=;A@3ED]B8-IAB>]8AB?A8LI:;=7B:Q9;:<;4B<6CO?>?=E8?B;>=@=@>A>;@=;>B9@<=AIGEKA1B?]B;<]DFD1?:<;>5A9A=;I=?=]4?A@EA]GEJO=>F?=:GC<>E<?9?.43?=C=EAI?3?7M?>YJU?@;9>=D"
"E@?B>A9?]DFE><B:97=A<><;@126=?]<@7C7I@<?:]<]8@A;>F@FOD@2K:;9=@<E4P<;C=9JA=CBD;@9:?^=>9CU=?]ED;B=3EB:<A5CA?JA]?@7@7B:?DA<8=8/4<6=]EB9?=@:A@<BA]=DFE;<@:87D>?]A9OJ]?]E?1F3?)?%@>:A5J?A=9@=EF51;<?DBAH/;JA<D@B-CEGD<=64M?<8<2?AD=]EBH?>C<8L:A:B?]@?C<AF8>BA=@A@E<@=@=C?A@>=46C/3?]JHB?`9J@?5O?#B?';<1?],;H7B]?G"
"A5C9<A3?E9?;39C1?@?%?^=P5?B?]9?F,8?3E@75<?E?jF?;/?],?/:?`C?]=?]H;>?O?9?a37@8E?c3?aM?`1/B:)9@?3BJ?>E;GH<J?5@3E6E]F?E<3?`8?E]/M;A]?8O?M?`4=1<>93:?]>D<DF;FK-?ADH6DB]@7OX?^;W?=5E?H1A3E7?N?]F?A3?]A?^8?/75?A2@84?7$J?_$3:H?GR*R?/AJ?5R%H?H]JA9?M=DB>]FGDF=AD;G3A>9D]K=E:@A9@HB=B=H9><B:=@:@A;A<9ABA]C>:@>=H@M?H"
"L;7=93E=)9?/=87C:9?=^?9?]3B?]=F]5A/1J9C?D?]2?<O6?c<?UEC9?^3?c74?D9?^/98RE97B?E=I>14BD>]:9BO4?_42)?/?^J<4,?9?<&'>?]/?53?J4.3@>+O9]8J?N9?MJ9:7?6?aL2?OJ?^-?^3;:@B8?]E?i=?RN?]6?R9/?_83?>6CA:?=3?:@8?9?<B?n86?_E5?<?P?]9:?O8)9]?]/?O=6?]3?E9HE4?_<?J;]1C<7?]=5?9?`4=D8HJ/?^:=71=@]U?=4=?>F=8=AGJ?3?:JO>I?;W?/[?"
"6?<?3E?^:?L?^>Y?8FR=IF?9JAI-?]E?];CLABF6?R?=?JBEJ9?E;?;:AE6H<CEU;?3>J?>9J89?H9]@C93H?7A5ABMC?]@JD?9=<=<69G@B:8Q2:C7B?K?]F?^.1?]J?_8O9<E?0=BA9?b8C?RO?O?f=9F?a1?]L;O?_J?bC?]:?`E?^GJ?^A?_/5@C];E?^/?JBRIAWX?]EIUL?3?^OC?G?^H?]Q?]D<>?CJ?L2?_3/?^J3?OH?E?31E30?EJ]P/E]=S@B.?C/?]E?A?H86E?]JE]UO/?E?]AE:?^6N3A]"
"IA@F?8?DFA=>)L>@8?JA3?_IE?]I?_BLB?@?;GBE?`9?]@,?H,?0?oF?H9?H?gE?OF?J?^DF=B?<?]E@:G@?K<?CF&/B?'?^G/?]J=?7?@9H<9J?L6D?6,O?7T,6<3@;:E0?<?365?IY,?<?FO?_G3Y?JY?^G?HE?J=]KAE?;?^J?:9?]/B?L?A78ME3IO=F?J?O?:?E@]5:?@L;ID,F<9?9FEG?cJ?cA)?_9E;?7@]9<689AC9=;6=E<BK6:2:=E@]>61GB06?AGE?A@;ECAJE]O?9U@^;BC<5@E=<;D@=<"
"@;AC>=EA>C=:1?49?G?]B],O?];?]<?39?=&?5]?B?]3E?]8?9>36.?]5?3?]3E?;59A)?9]?L;G?]LE?]M=J?_7L79?=<?/?^C?^O?]E]F?E?]E?]@7?:?^B?]>@?B]@E=DE59/?/?>7D9?3?]9R?E7A?ER?]E6?E49?>=;=9<19?L?/=C]H?E?^D/97?]<?@:9?89?_IB?HIE?]OAE?`E6FED1?)?^;=?4<J?]H?B<D@G@H><BKB?;I'BCGJ5F?RBM<E?2J?/3A0?E?^9?1;E/G9O?E87,?_9/5:C9E?9C"
"7E@?CFA?,?]BJE)?RC?>A?]B?EF?/;EC5B9?]E;J9.?9<IA9@B?R79]A=A@]B>A<B<:F6@9@:];B9E9]?^=@9?:E?]EAC?;@8G;@<GJP?^./;?EJ?_E>X?L?K3:E=7?_1?]B@698AE?]1O?]9?_=]D]?_E>?]8B<F?8BG8=?F<><C?R?%?])?=E?]9EU?9:<34E?9B]F?:?%?C;A<JNEPHEJ?879?^79EC/?3?^/?>X9?/6?^@?:6?]KQ9C?]3?EIJ?E,E$R,L?];7:J?_E>5?_B?]=:DBDCFDF<:?@6A,;]"
"6E<?]3J?]7O?`%?CME?^JA7BJD,?,?^DJ0J?J]D7;?O?E?_9?^9?O9]:C?8GJLCD:MH6?G)JB>B?A?>?I;<G9I<>:?>=@=4KC]?@:9?/?]3?f1%<4?_9@?O?dD6:/?_O?`D69?fOE?^5?O?3Q9G?^1?jO%9?%?O?fERB96:?R3?]9?^OE?]9?b9?d9?_G)E9?`F?]2?<R3R3?E9?L?E9O]?;?cK9E?8D3?]J?b3D?]9?`=?]9?^J?C?<JHGCD=>?I?]IW?ECF;HWAW'EC9</?<J;?BO=?]39A?B]?>D861?B"
"R9?^/G3;?>H3?OC?A?9AS<,?0/?<?]G;O<F3FA6FIA?A9D2D@<L<@P?>F;]FB@B@;6<=FA@B>AB?@D?ADB:B<?A@<IB;8I;E9E8GCAD?];=G=<E8A]?<LCBOJE]9;A9RS?E?]U/IO?]JEJ@EH?^J?J<:<=A6I?fD<F]?]G=?]B]9>9?]I@<D=MG@=>;?`3?]BJE?]E3J?<E09?J9?9?_%?HE9B?GAF6/?]/?9?%?E6?E?9E]?_=?cCE93EL2A]G?09?`9?c9?]9%?5?NC?5?]<Q?]B@]CBA>F@86F9?]9?5<"
"?9?a>9?bL?9?^O9C<?]3]?AJ?-?_OE?]3?F3EO?J?89/?]/E?]>@:]EB@?]J?c<@:6HE?FJ9?84M9?]=CK<>ENE=>F?`J?]L'?W?`=)B?]9?]5:?`J?]L?RA]4E?]AJ?_J]47?OJ?`4.9?E?_<?9?J?8>8A?EH?]Y?]D?^A?_2;E?E?T?]R?U?^J?]B9@BF5N39:?]3?^A?)?]8?`4?J?a<9E?^6@5@?K?^R?]:7?]C?H?^/?aJLR?bB?];EN?]O?bE?E?c@?^=N?]AFIG?FE@CBA?A9?E[?]FB>3'G?B3@?"
"^J?7?A3E?_9?E9?]DL;?G/D?3?^L?]8?9?aJ?]J?`ADE?^E?CB?]9?]9?-9E?41?CG24J,9?]0B6@=6OR8936><:<D@890FD73F9;:6:?lHCF?^E9E9?J9?`3?uD?6?]6?^%]?`%?;?OKJ?_F?=?]F?^E?EU?E@=BE?cF39A;?^9AB?&?7LA=8?9?^A?,CI4HFB?B/6?`O?]I?^O?_C:R<E,?^D?E9J?E?>;?93?^J9A/H$GR3?]=9?J6?Y?B?>3]E0CA?<:?@A]>:E>;B]?8F:E3E,?_E?U?a%?:J9?^U(9"
"<LH7GJH>DB?6DO<S?H:Q/@AB=?F8=9/)0=@9];4=A?G9;=A=59GE(G?H>BDH@CDA>;>=]?=]@?]8=>C<?C?L6?]J?EAK?XI?EA?;R<B?]/?]I=E]1?UE?A?3F]2?^C?7?0?]92I<?9?^K?IJ?9C?]J?ED?P?]@HK@BE1O?L?E9EOA=?G?]@:]?^69?8:9?^MU?]B;=@5:6>B?@?5?J3BC?E?^F?E<?9?H9?^4?;?/?695EA?_AO?89?]>?]9?;?^9]?]/9?E]?,K?]G9?@BAJ?E9<F?9?],9GD?<?`9DH?F@"
"O]?@?>8:@;><;,?^U?]YCJBE;]I>9@?9)E?]9E;?O?]OJ?]=C?3D-H?]@E&?_HO7C?;<C?]YE]GF9E?^A039?496.<93?^R]?B/?a9]N3]G:34?@?;?B5=@?@]>:>?I:3BD6C@?5?BE?]/E]?]EC60U<3H6?D?;1:;E46;?]5?3J9?BCG?9?3?]9]R2?]YR,HA93?^J?;903G<?^F?/?]Y?`H<?`A?DRB]=]HA9C78:;]9A3<5<W<B?A?9N<KL?3:37,0<H?8DE:;9G9E?;93:?]U,?=:?R?]8?=M9?EL?_F"
"?RDIO?^BO9?F96/EB37?OP-?]@?&J9C23?C9?]9?3?]A9@?9?:?];F6AB@A7?@?]8F?FB;A?FM?`M?/?`E<H>9?]E=F<?]8O?;9?BE3A<5PE?B:9?9?HE<BE;?^9E]<?;7=CBF=AE>?9?]9D]<>D<E?G,B8C>D]GE>@=^<B>?<8?]3?`@;U?I?]E?2?W?^'?]F/?_3?]AE?F]@?]3JEP?`9D?]3?`=?3]J3?^1,?9?]<J<=3?,?bO?3?_D?G5?_:9?c875><;?8]=?^<?]0@1?,?f9?^<?^/?B09<9?%?]6?"
"]L9C*?_9:?b=U?`F?]A9EHI>?^J3?b,)?3?`D?_=J?]<>E/EJ<H89?c=?;1A<XG?7EK?E?=?B5?b/:9?9@?E?3:,C?^BR9FE?<R?_G?]/?`;J5?O<6<7A625:@F47DO-@8?>;=<H?+6?:B/?@5>:;<59>]?;?AF@]=C@?A]@A@E]A]D>ONUA]<96VH6E]JC7BE@?<CE?]E3J?]A?E%<?3?G=6OJ?]Y,7KR9?]9?^DE3)DV?^)?_Y?^>J@;?=JN9?<B79D<F?A>D@9D=`?#?]E9?=?]F<?^38?<?J<J7WFE?b"
"<9:9;?_4?`3?]J?9E9?_:K?2?`E?^O7:B1E3?_E?fJ?cB/?_2?39]?><A)9?7A?`8?eY?Y?]Y?^:G?`G?<?]EQ?E?]IR4MG<E?]E?9;L7J?MC?c58;98E?g=G@DGJ/E,7F:BGDKE7?CBFNEA>:D?EJ?]O?]MBY?E?J?fH?E?aI/?D?7?-J?b9/>/?c/?]9?bO?]9DHD?]7?`E1?/?/?E9KA?J9?,]J:?`D?];A?:A936]A?_3E?]C?c3?^J?_29EJ?^9F?L?b/EY/?_Y?fE?cE79U?^E?mE?/?9?^8;,?J,E"
"DHC?]J?`AM9E]?E3?<93J?3?9?8E?_9?9;E9K<=J29A?f5E9?]YOE?9?G?]Y<7?O?]<H8B?]<?3J?J]8?^3J/9P?]9?^/?AD>?38G96;B39?@?09EF?]@?IE0FOE8?^O?3?dD=]?]C;96M?_E?]E?]H0?E?YE?cAE?b1E?/;E?^@?E?a:H?-?^A?E8HEI?E?]<>]?=7;=;@5?'9?]5?;AE3?BOA?;B8'9W6='B@?/?:5?JOA?B]/?6?=E?RN?=B+<@/E?=?J?<E,OJ7?^<?<H?M@F:B;29D9;4/)5O3]9/?]"
"CE=9?],?+:7B7?@7?]=:B>@^60?;]?5?E]@>6943?hB]D4?]@G<7]K5?<]8H>].B<7@C8<9EBA1K>:B;5BE9B5FA@6=?<BE9]7F?C?;9<>]<@=8CBH<]9>]=CB;>@<=>:=?<";

const double compress_vals[char_e - char_s + 1] = 
    {-0.99191575, -0.955417, -0.925217, -0.87192775, -0.8353087499999999, -0.79376225, -0.7521912222222222, -0.7211734999999999, -0.6842236666666666, -0.6495354444444446, -0.6066062333333334, -0.5705911935483873, -0.5333852142857143, -0.4977529599999999, -0.4617034339622642, -0.4280493521126759, -0.3930658846153848, -0.3562839680851063, -0.32210842748091595, -0.28638591366906474, -0.25082044382022484, -0.2177653593073593, -0.18336263157894744, -0.14849799452054788, -0.11322629255319143, -0.07861064571428576, -0.044194587947882745, -0.009447826356589157, 0.0, 0.02449980906148867, 0.058887281355932165, 0.09310184199134201, 0.1286132636103152, 0.16182661875000015, 0.19795722314049594, 0.23227418264840172, 0.267653596153846, 0.30229703875969, 0.33605759829059817, 0.3711898414634147, 0.40819006249999995, 0.44264849206349216, 0.4775844999999999, 0.5102675952380951, 0.54893288, 0.5832057878787877, 0.6154508, 0.6539295789473684, 0.6925377777777778, 0.734762625, 0.7674997500000001, 0.7988967777777778, 0.83530875, 0.87192775, 0.9324133333333333, 0.9774676666666666, 0.999644};
int compress_pattern[pattern_elem_num];
double patterns[pattern_elem_num];

struct node_t{
    int k[hw];
    double v;
    node_t* p_n_node;
};

inline int calc_hash(const int *p){
    int seed = 0;
    for (int i = 0; i < hw; ++i)
        seed ^= p[i] << (i / 4);
    return seed & hash_mask;
}

inline void hash_table_init(node_t** hash_table){
    for(int i = 0; i < hash_table_size; ++i)
        hash_table[i] = NULL;
}

inline node_t* node_init(const int *key, double val){
    node_t* p_node = NULL;
    p_node = (node_t*)malloc(sizeof(node_t));
    for (int i = 0; i < hw; ++i)
        p_node->k[i] = key[i];
    p_node->v = val;
    p_node->p_n_node = NULL;
    return p_node;
}

inline bool compare_key(const int *a, const int *b){
    for (int i = 0; i < hw; ++i){
        if (a[i] != b[i])
            return false;
    }
    return true;
}

inline void register_hash(node_t** hash_table, const int *key, int hash, double val){
    if(hash_table[hash] == NULL){
        hash_table[hash] = node_init(key, val);
    } else {
        node_t *p_node = p_node = hash_table[hash];
        node_t *p_pre_node = NULL;
        p_pre_node = p_node;
        while(p_node != NULL){
            if(compare_key(key, p_node->k)){
                p_node->v = val;
                return;
            }
            p_pre_node = p_node;
            p_node = p_node->p_n_node;
        }
        p_pre_node->p_n_node = node_init(key, val);
    }
}

inline double get_val_hash(node_t** hash_table, const int *key, int hash){
    node_t *p_node = hash_table[hash];
    while(p_node != NULL){
        if(compare_key(key, p_node->k))
            return p_node->v;
        p_node = p_node->p_n_node;
    }
    return -inf;
}

inline void hash_table_copy(node_t** to_table, node_t** fr_table){
    for(int i = 0; i < hash_table_size; ++i){
        
    }
}

struct board_param{
    unsigned long long trans[board_index_num][6561][hw];
    unsigned long long neighbor8[board_index_num][6561][hw];
    bool legal[6561][hw];
    int put[hw2][board_index_num];
    int board_translate[board_index_num][8];
    int board_rev_translate[hw2][4][2];
    int pattern_space[board_index_num];
    int reverse[6561];
    int pow3[15];
    int rev_bit3[6561][8];
    int pop_digit[6561][8];
    int digit_pow[3][10];
    int put_idx[hw2][10];
    int put_idx_num[hw2];
};

struct eval_param{
    double weight[hw2];
    double pattern_weight, cnt_weight, canput_weight, weight_weight, confirm_weight, pot_canput_weight, open_weight;
    double cnt_bias;
    double weight_sme[param_num];
    double avg_canput[hw2];
    int canput[6561];
    int cnt_p[6561], cnt_o[6561];
    double weight_p[hw][6561], weight_o[hw][6561];
    int pattern_variation[pattern_num], pattern_space[pattern_num];
    int pattern_translate[pattern_num][8][10][2];
    double pattern_each_weight[pattern_num];
    double pattern[pattern_num][59049];
    int confirm_p[6561], confirm_o[6561];
    int pot_canput_p[6561], pot_canput_o[6561];
    double open_eval[40];
};

struct search_param{
    node_t *memo_lb[hash_table_size];
    node_t *memo_ub[hash_table_size];
    node_t *previous_memo[hash_table_size];
    int max_depth;
    int min_max_depth;
    int strt, tl;
    int turn;
    int searched_nodes;
    int vacant_lst[hw2];
    int vacant_cnt;
};

struct board_priority_move{
    int b[board_index_num];
    double priority;
    int move;
    double open_val;
};

struct board_priority{
    int b[board_index_num];
    double priority;
    double n_open_val;
};

struct open_vals{
    double p_open_val, o_open_val;
    int p_cnt, o_cnt;
};

board_param board_param;
eval_param eval_param;
search_param search_param;

int xorx=123456789, xory=362436069, xorz=521288629, xorw=88675123;
inline double myrandom(){
    int t = (xorx^(xorx<<11));
    xorx = xory;
    xory = xorz;
    xorz = xorw;
    xorw = xorw=(xorw^(xorw>>19))^(t^(t>>8));
    return (double)(xorw) / 2147483648.0;
}

inline int randint(int fr, int to){
    return fr + (int)(myrandom() * (to - fr + 1));
}

#define prob_num_step 10000
#define prob_step_width (2.0 / prob_num_step)
double prob_arr[prob_num_step];

void prob_init(){
    double x;
    for (int idx = 0; idx < prob_num_step; idx++){
        x = -prob_step_width * idx;
        prob_arr[idx] = exp(x * 1.5);
    }
}
double prob(double dis){
    if (dis >= 0)
        return 1.0;
    //return exp(dis * 1.5);
    return prob_arr[min(prob_num_step - 1, (int)(-dis / prob_step_width))];
}

inline int tim(){
    return static_cast<int>(chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now().time_since_epoch()).count());
}

void print_board_line(int tmp){
    int j;
    for (j = 0; j < hw; ++j){
        if (tmp % 3 == 0){
            cerr << ". ";
        }else if (tmp % 3 == 1){
            cerr << "P ";
        }else{
            cerr << "O ";
        }
        tmp /= 3;
    }
}

void print_board(int* board){
    int i, j, idx, tmp;
    for (i = 0; i < hw; ++i){
        tmp = board[i];
        for (j = 0; j < hw; ++j){
            if (tmp % 3 == 0){
                cerr << ". ";
            }else if (tmp % 3 == 1){
                cerr << "P ";
            }else{
                cerr << "O ";
            }
            tmp /= 3;
        }
        cerr << endl;
    }
    cerr << endl;
}

int reverse_line(int a) {
    int res = 0;
    for (int i = 0; i < hw; ++i) {
        res <<= 1;
        res |= 1 & (a >> i);
    }
    return res;
}

inline int check_mobility(const int p, const int o){
	int p1 = p << 1;
    int res = ~(p1 | o) & (p1 + o);
    int p_rev = reverse_line(p), o_rev = reverse_line(o);
    int p2 = p_rev << 1;
    res |= reverse_line(~(p2 | o_rev) & (p2 + o_rev));
    res &= ~(p | o);
    // cerr << bitset<8>(p) << " " << bitset<8>(o) << " " << bitset<8>(res) << endl;
    return res;
}

int trans(int pt, int k) {
    if (k == 0)
        return pt >> 1;
    else
        return pt << 1;
}

int move_line(int p, int o, const int place) {
    int rev = 0;
    int rev2, mask, tmp;
    int pt = 1 << place;
    for (int k = 0; k < 2; ++k) {
        rev2 = 0;
        mask = trans(pt, k);
        while (mask && (mask & o)) {
            rev2 |= mask;
            tmp = mask;
            mask = trans(tmp, k);
            if (mask & p)
                rev |= rev2;
        }
    }
    // cerr << bitset<8>(p) << " " << bitset<8>(o) << " " << bitset<8>(rev | pt) << endl;
    return rev | pt;
}

int create_p(int idx){
    int res = 0;
    for (int i = 0; i < hw; ++i){
        if (idx % 3 == 1){
            res |= 1 << i;
        }
        idx /= 3;
    }
    return res;
}

int create_o(int idx){
    int res = 0;
    for (int i = 0; i < hw; ++i){
        if (idx % 3 == 2){
            res |= 1 << i;
        }
        idx /= 3;
    }
    return res;
}

int board_reverse(int idx){
    int p = create_p(idx);
    int o = create_o(idx);
    int res = 0;
    for (int i = hw_m1; i >= 0; --i){
        res *= 3;
        if (1 & (p >> i))
            res += 2;
        else if (1 & (o >> i))
            ++res;
    }
    return res;
}

const int translate[hw2] = {
    0, 1, 2, 3, 3, 2, 1, 0,
    1, 4, 5, 6, 6, 5, 4, 1,
    2, 5, 7, 8, 8, 7, 5, 2,
    3, 6, 8, 9, 9, 8, 6, 3,
    3, 6, 8, 9, 9, 8, 6, 3,
    2, 5, 7, 8, 8, 7, 5, 2,
    1, 4, 5, 6, 6, 5, 4, 1,
    0, 1, 2, 3, 3, 2, 1, 0
};

void init(){
    int strt = tim();
    int i, j, k, l;
    double weight_buf[10];
    int all_idx = 0;
    for (i = 0; i < hw2; ++i)
        eval_param.avg_canput[i] = params[all_idx++];
    for (i = 0; i < 10; i++)
        weight_buf[i] = params[all_idx++];
    for (i = 0; i < hw2; i++)
        eval_param.weight[i] = weight_buf[translate[i]];
    for (i = 0; i < param_num; ++i)
        eval_param.weight_sme[i] = params[all_idx++];
    all_idx = 0;
    for (i = 0; i < board_index_num; ++i)
        board_param.pattern_space[i] = consts[all_idx++];
    for (i = 0; i < board_index_num; ++i){
        for (j = 0; j < board_param.pattern_space[i]; ++j)
            board_param.board_translate[i][j] = consts[all_idx++];
    }
    for (i = 0; i < pattern_num; ++i)
        eval_param.pattern_space[i] = consts[all_idx++];
    for (i = 0; i < pattern_num; ++i)
        eval_param.pattern_variation[i] = consts[all_idx++];
    for (i = 0; i < pattern_num; ++i){
        for (j = 0; j < eval_param.pattern_variation[i]; ++j){
            for (k = 0; k < eval_param.pattern_space[i]; ++k){
                eval_param.pattern_translate[i][j][k][0] =consts[all_idx] / hw;
                eval_param.pattern_translate[i][j][k][1] = consts[all_idx++] % hw;
            }
        }
    }
    int idx;
    for (i = 0; i < hw2; ++i){
        idx = 0;
        for (j = 0; j < board_index_num; ++j){
            for (k = 0; k < board_param.pattern_space[j]; ++k){
                if (board_param.board_translate[j][k] == i){
                    board_param.board_rev_translate[i][idx][0] = j;
                    board_param.board_rev_translate[i][idx++][1] = k;
                }
            }
        }
        for (j = idx; j < 4; ++j)
            board_param.board_rev_translate[i][j][0] = -1;
    }
    for (i = 0; i < hw2; ++i){
        for (j = 0; j < board_index_num; ++j){
            board_param.put[i][j] = -1;
            for (k = 0; k < board_param.pattern_space[j]; ++k){
                if (board_param.board_translate[j][k] == i)
                    board_param.put[i][j] = k;
            }
        }
    }
    cerr << "before unzipping" << endl;
    all_idx = 0;
    for (i = 0; i < super_compress_pattern.length(); ++i){
        if ((int)super_compress_pattern[i] >= num_s){
            for (j = 0; j < (int)super_compress_pattern[i] - num_s + 1; ++j){
                compress_pattern[all_idx] = compress_pattern[all_idx - 1];
                ++all_idx;
            }
        } else {
            compress_pattern[all_idx] = super_compress_pattern[i];
            ++all_idx;
        }
    }
    cerr << "unziped elems: " << all_idx << endl;
    for (i = 0; i < pattern_elem_num; ++i)
        patterns[i] = compress_vals[compress_pattern[i] - char_s];
    all_idx = 0;
    for (i = 0; i < pattern_num; ++i){
        for (j = 0; j < (int)pow(3, eval_param.pattern_space[i]); ++j)
            eval_param.pattern[i][j] = patterns[all_idx++];
    }
    int p, o, mobility, canput_num, rev;
    for (i = 0; i < 6561; ++i){
        board_param.reverse[i] = board_reverse(i);
        p = reverse_line(create_p(i));
        o = reverse_line(create_o(i));
        eval_param.cnt_p[i] = 0;
        eval_param.cnt_o[i] = 0;
        for (j = 0; j < hw; ++j){
            eval_param.cnt_p[i] += 1 & (p >> j);
            eval_param.cnt_o[i] += 1 & (o >> j);
        }
        mobility = check_mobility(p, o);
        canput_num = 0;
        for (j = 0; j < hw; ++j){
            if (1 & (mobility >> (hw_m1 - j))){
                rev = move_line(p, o, hw_m1 - j);
                ++canput_num;
                board_param.legal[i][j] = true;
                for (k = 0; k < board_index_num; ++k){
                    board_param.trans[k][i][j] = 0;
                    for (l = 0; l < board_param.pattern_space[k]; ++l)
                        board_param.trans[k][i][j] |= (unsigned long long)(1 & (rev >> (7 - l))) << board_param.board_translate[k][l];
                    board_param.neighbor8[k][i][j] = 0;
                    board_param.neighbor8[k][i][j] |= (0b0111111001111110011111100111111001111110011111100111111001111110 & board_param.trans[k][i][j]) << 1;
                    board_param.neighbor8[k][i][j] |= (0b0111111001111110011111100111111001111110011111100111111001111110 & board_param.trans[k][i][j]) >> 1;
                    board_param.neighbor8[k][i][j] |= (0b0000000011111111111111111111111111111111111111111111111100000000 & board_param.trans[k][i][j]) << hw;
                    board_param.neighbor8[k][i][j] |= (0b0000000011111111111111111111111111111111111111111111111100000000 & board_param.trans[k][i][j]) >> hw;
                    board_param.neighbor8[k][i][j] |= (0b0000000001111110011111100111111001111110011111100111111000000000 & board_param.trans[k][i][j]) << hw_m1;
                    board_param.neighbor8[k][i][j] |= (0b0000000001111110011111100111111001111110011111100111111000000000 & board_param.trans[k][i][j]) >> hw_m1;
                    board_param.neighbor8[k][i][j] |= (0b0000000001111110011111100111111001111110011111100111111000000000 & board_param.trans[k][i][j]) << hw_p1;
                    board_param.neighbor8[k][i][j] |= (0b0000000001111110011111100111111001111110011111100111111000000000 & board_param.trans[k][i][j]) >> hw_p1;
                    board_param.neighbor8[k][i][j] &= ~board_param.trans[k][i][j];
                }
            } else
                board_param.legal[i][j] = false;
        }
        eval_param.canput[i] = canput_num;
    }
    for (i = 0; i < hw2; ++i){
        board_param.put_idx_num[i] = 0;
        for (j = 0; j < board_index_num; ++j){
            if (board_param.put[i][j] != -1)
                board_param.put_idx[i][board_param.put_idx_num[i]++] = j;
        }
    }
    for (i = 0; i < 15; ++i)
        board_param.pow3[i] = (int)pow(3, i);
    for (i = 0; i < 6561; ++i){
        for (j = 0; j < 8; ++j){
            board_param.rev_bit3[i][j] = board_param.pow3[j] * (2 - (i / board_param.pow3[j]) % 3);
            board_param.pop_digit[i][j] = i / board_param.pow3[j] % 3;
        }
    }
    for (i = 0; i < hw; ++i){
        for (j = 0; j < 6561; ++j){
            eval_param.weight_p[i][j] = 0.0;
            eval_param.weight_o[i][j] = 0.0;
            for (k = 0; k < 8; ++k){
                if (board_param.pop_digit[j][k] == 1)
                    eval_param.weight_p[i][j] += eval_param.weight[i * hw + k];
                else if (board_param.pop_digit[j][k] == 2)
                    eval_param.weight_o[i][j] += eval_param.weight[i * hw + k];
            }
        }
    }
    bool flag;
    for (i = 0; i < 6561; ++i){
        eval_param.confirm_p[i] = 0;
        eval_param.confirm_o[i] = 0;
        flag = true;
        for (j = 0; j < hw; ++j)
            if (!board_param.pop_digit[i][j])
                flag = false;
        if (flag){
            for (j = 0; j < hw; ++j){
                if (board_param.pop_digit[i][j] == 1)
                    ++eval_param.confirm_p[i];
                else
                    ++eval_param.confirm_o[i];
            }
        } else {
            flag = true;
            for (j = 0; j < hw; ++j){
                if (board_param.pop_digit[i][j] != 1)
                    break;
                ++eval_param.confirm_p[i];
                if (k == hw_m1)
                    flag = false;
            }
            if (flag){
                for (j = hw_m1; j >= 0; --j){
                    if (board_param.pop_digit[i][j] != 1)
                        break;
                    ++eval_param.confirm_p[i];
                    if (k == hw_m1)
                        flag = false;
                }
            }
            flag = true;
            for (j = 0; j < hw; ++j){
                if (board_param.pop_digit[i][j] != 2)
                    break;
                ++eval_param.confirm_o[i];
                if (k == hw_m1)
                    flag = false;
            }
            if (flag){
                for (j = hw_m1; j >= 0; --j){
                    if (board_param.pop_digit[i][j] != 2)
                        break;
                    ++eval_param.confirm_o[i];
                    if (k == hw_m1)
                        flag = false;
                }
            }
        }
    }
    for (i = 0; i < 6561; ++i){
        eval_param.pot_canput_p[i] = 0;
        eval_param.pot_canput_o[i] = 0;
        for (j = 0; j < hw_m1; ++j){
            if (board_param.pop_digit[i][j] == 0){
                if (board_param.pop_digit[i][j + 1] == 2)
                    ++eval_param.pot_canput_p[i];
                else if (board_param.pop_digit[i][j + 1] == 1)
                    ++eval_param.pot_canput_o[i];
            }
        }
        for (j = 1; j < hw; ++j){
            if (board_param.pop_digit[i][j] == 0){
                if (board_param.pop_digit[i][j - 1] == 2)
                    ++eval_param.pot_canput_p[i];
                else if (board_param.pop_digit[i][j - 1] == 1)
                    ++eval_param.pot_canput_o[i];
            }
        }
    }
    for (i = 0; i < 3; ++i){
        for (j = 0; j < 10; ++j)
            board_param.digit_pow[i][j] = i * board_param.pow3[j];
    }
    for (i = 0; i < 40; ++i)
        eval_param.open_eval[i] = min(1.0, pow(2.0, 2.0 - 0.667 * i) - 1.0);
}

inline double pattern_eval(const int *board){
    int i, j, k, tmp;
    double res = 0.0;
    for (i = 0; i < 3; ++i){
        for (j = 0; j < eval_param.pattern_variation[i]; ++j){
            tmp = 0;
            for (k = 0; k < eval_param.pattern_space[i]; ++k)
                tmp += board_param.digit_pow[board_param.pop_digit[board[eval_param.pattern_translate[i][j][k][0]]][eval_param.pattern_translate[i][j][k][1]]][k];
            res += eval_param.pattern[i][tmp] * eval_param.pattern_each_weight[i];
        }
    }
    res += eval_param.pattern[3][board[21]] * eval_param.pattern_each_weight[3];
    res += eval_param.pattern[3][board[32]] * eval_param.pattern_each_weight[3];
    res += eval_param.pattern[4][board[0]] * eval_param.pattern_each_weight[4];
    res += eval_param.pattern[4][board[7]] * eval_param.pattern_each_weight[4];
    res += eval_param.pattern[4][board[8]] * eval_param.pattern_each_weight[4];
    res += eval_param.pattern[4][board[15]] * eval_param.pattern_each_weight[4];
    return res;
}

inline double canput_eval(const int *board){
    int i;
    int res = 0;
    for (i = 0; i < board_index_num; ++i)
        res += eval_param.canput[board[i]];
    return ((double)res - eval_param.avg_canput[search_param.turn]) / max(1.0, (double)res + eval_param.avg_canput[search_param.turn]);
}

inline double cnt_eval(const int *board){
    int i;
    int cnt_p = 0, cnt_o = 0;
    for (i = 0; i < hw; ++i){
        cnt_p += eval_param.cnt_p[board[i]];
        cnt_o += eval_param.cnt_o[board[i]];
    }
    return ((double)cnt_p - cnt_o) / max(1, cnt_p + cnt_o);
}

inline double weight_eval(const int *board){
    int i;
    double res_p = 0.0, res_o = 0.0;
    int cnt_p = 0, cnt_o = 0;
    for (i = 0; i < hw; ++i){
        res_p += eval_param.weight_p[i][board[i]];
        res_o += eval_param.weight_o[i][board[i]];
    }
    return (res_p - res_o) / (abs(res_p) + abs(res_o));
}

inline double confirm_eval(const int *board){
    int res_p, res_o;
    res_p = eval_param.confirm_p[board[0]];
    res_p += eval_param.confirm_p[board[7]];
    res_p += eval_param.confirm_p[board[8]];
    res_p += eval_param.confirm_p[board[15]];
    res_o = eval_param.confirm_o[board[0]];
    res_o += eval_param.confirm_o[board[7]];
    res_o += eval_param.confirm_o[board[8]];
    res_o += eval_param.confirm_o[board[15]];
    return (double)(res_p - res_o) / max(1, res_p + res_o);
}

inline double pot_canput_eval(const int *board){
    int i;
    int res_p = 0, res_o = 0;
    for (i = 0; i < board_index_num; ++i){
        res_p += eval_param.pot_canput_p[board[i]];
        res_o += eval_param.pot_canput_o[board[i]];
    }
    return (double)(res_p - res_o) / max(1, res_p + res_o);
}

inline double evaluate(const int *board, const double open){
    double pattern = pattern_eval(board);
    double cnt = cnt_eval(board);
    double canput = canput_eval(board);
    double weight = weight_eval(board);
    double confirm = confirm_eval(board);
    double pot_canput = pot_canput_eval(board);
    //double open = eval_param.open_eval[min(39, open_val)];
    return 
        pattern * eval_param.pattern_weight + 
        cnt * eval_param.cnt_weight + 
        canput * eval_param.canput_weight + 
        weight * eval_param.weight_weight + 
        confirm * eval_param.confirm_weight + 
        pot_canput * eval_param.pot_canput_weight + 
        open * eval_param.open_weight;
}

inline double end_game(const int *board){
    int res = 0, i, j, p, o;
    for (i = 0; i < hw; ++i){
        res += eval_param.cnt_p[board[i]];
        res -= eval_param.cnt_o[board[i]];
    }
    return (double)res * 1000.0;
}

inline int move_open(int *board, int (&res)[board_index_num], int coord){
    int i, j, tmp;
    unsigned long long rev = 0, neighbor = 0;
    for (i = 0; i < board_index_num; ++i){
        res[i] = board_param.reverse[board[i]];
        if (board_param.put[coord][i] != -1){
            rev |= board_param.trans[i][board[i]][board_param.put[coord][i]];
            neighbor |= board_param.neighbor8[i][board[i]][board_param.put[coord][i]];
        }
    }
    for (i = 0; i < hw2; ++i){
        if (1 & (rev >> i)){
            for (j = 0; j < 4; ++j){
                if (board_param.board_rev_translate[i][j][0] == -1)
                    break;
                res[board_param.board_rev_translate[i][j][0]] += board_param.rev_bit3[res[board_param.board_rev_translate[i][j][0]]][board_param.board_rev_translate[i][j][1]];
            }
        }
    }
    int open_val = 0;
    for (i = 0; i < hw2; ++i){
        if(1 & (neighbor >> i))
            open_val += (int)(board_param.pop_digit[board[i >> 3]][i & 0b111] == 0);
    }
    return open_val;
}

open_vals open_val_forward(int *board, int depth, bool player){
    open_vals res;
    if (depth == 0){
        res.p_open_val = 0.0;
        res.o_open_val = 0.0;
        res.p_cnt = 0;
        res.o_cnt = 0;
        return res;
    }
    --depth;
    int i, j;
    int n_board[board_index_num];
    open_vals tmp;
    res.p_open_val = -inf;
    res.o_open_val = inf;
    double open_val = -inf;
    bool passed = false;
    for (j = 0; j < search_param.vacant_cnt; ++j){
        for (i = 0; i < board_param.put_idx_num[search_param.vacant_lst[j]]; ++i){
            if (board_param.legal[board[board_param.put_idx[search_param.vacant_lst[j]][i]]][board_param.put[search_param.vacant_lst[j]][board_param.put_idx[search_param.vacant_lst[j]][i]]]){
                passed = false;
                open_val = max(open_val, eval_param.open_eval[move_open(board, n_board, search_param.vacant_lst[j])]);
                tmp = open_val_forward(n_board, depth, !player);
                if (res.p_open_val < tmp.p_open_val){
                    res.p_open_val = tmp.p_open_val;
                    res.p_cnt = tmp.p_cnt;
                }
                if (res.o_open_val > tmp.o_open_val){
                    res.o_open_val = tmp.o_open_val;
                    res.o_cnt = tmp.o_cnt;
                }
            }
        }
    }
    if (passed){
        res.p_open_val = 0.0;
        res.o_open_val = 0.0;
        res.p_cnt = 0;
        res.o_cnt = 0;
        return res;
    }
    if (player){
        res.p_open_val += open_val;
        ++res.p_cnt;
    } else {
        res.o_open_val += open_val;
        ++res.o_cnt;
    }
    return res;
}

int cmp(board_priority p, board_priority q){
    return p.priority > q.priority;
}

double nega_alpha_light(int *board, const int depth, double alpha, double beta, const int skip_cnt, double p_open_val, double o_open_val, int p_cnt, int o_cnt){
    ++search_param.searched_nodes;
    if (tim() - search_param.strt > search_param.tl)
        return -inf;
    if (skip_cnt == 2)
        return end_game(board);
    else if (depth == 0)
        return evaluate(board, p_open_val / max(1, p_cnt) - o_open_val / max(1, o_cnt));
    bool is_pass = true;
    int i, j, k;
    double v = -65000.0, g;
    int n_board[board_index_num];
    ++p_cnt;
    for (j = 0; j < search_param.vacant_cnt; ++j){
        for (i = 0; i < board_index_num; ++i){
            if (board_param.put[search_param.vacant_lst[j]][i] != -1){
                if (board_param.legal[board[i]][board_param.put[search_param.vacant_lst[j]][i]]){
                    is_pass = false;
                    g = -nega_alpha_light(n_board, depth - 1, -beta, -alpha, 0, o_open_val, p_open_val + eval_param.open_eval[move_open(board, n_board, search_param.vacant_lst[j])], o_cnt, p_cnt);
                    if (beta <= g)
                        return g;
                    alpha = max(alpha, g);
                    v = max(v, g);
                    break;
                }
            }
        }
    }
    if (is_pass){
        for (i = 0; i < board_index_num; ++i)
            n_board[i] = board_param.reverse[board[i]];
        return -nega_alpha_light(n_board, depth, -beta, -alpha, skip_cnt + 1, o_open_val, p_open_val, o_cnt, p_cnt - 1);
    }
    return v;
}

double nega_alpha(int *board, const int depth, double alpha, double beta, const int skip_cnt, double p_open_val, double o_open_val, int p_cnt, int o_cnt){
    if (depth < simple_threshold)
        return nega_alpha_light(board, depth, alpha, beta, skip_cnt, p_open_val, o_open_val, p_cnt, o_cnt);
    ++search_param.searched_nodes;
    if (tim() - search_param.strt > search_param.tl)
        return -inf;
    if (skip_cnt == 2)
        return end_game(board);
    else if (depth == 0)
        return evaluate(board, p_open_val / max(1, p_cnt) - o_open_val / max(1, o_cnt));
    int hash = calc_hash(board);
    double lb, ub;
    lb = get_val_hash(search_param.memo_lb, board, hash);
    ub = get_val_hash(search_param.memo_ub, board, hash);
    if (lb != -inf){
        alpha = max(alpha, lb);
        if (alpha >= beta)
            return alpha;
    }
    if (ub != -inf){
        beta = min(beta, ub);
        if (alpha >= beta)
            return beta;
    }
    int i, j, k, canput = 0;
    double v = -65000.0, g;
    board_priority lst[30];
    ++p_cnt;
    double previous_val;
    for (j = 0; j < search_param.vacant_cnt; ++j){
        for (i = 0; i < board_param.put_idx_num[search_param.vacant_lst[j]]; ++i){
            if (board_param.legal[board[board_param.put_idx[search_param.vacant_lst[j]][i]]][board_param.put[search_param.vacant_lst[j]][board_param.put_idx[search_param.vacant_lst[j]][i]]]){
                lst[canput].n_open_val = p_open_val + eval_param.open_eval[move_open(board, lst[canput].b, search_param.vacant_lst[j])];
                previous_val = get_val_hash(search_param.previous_memo, lst[canput].b, calc_hash(lst[canput].b));
                if (previous_val != -inf){
                    lst[canput].priority = 1000.0 + previous_val;
                } else {
                    lst[canput].priority = lst[canput].n_open_val / p_cnt - o_open_val / max(1, o_cnt);
                }
                ++canput;
                break;
            }
        }
    }
    if (canput == 0){
        int n_board[board_index_num];
        for (i = 0; i < board_index_num; ++i)
            n_board[i] = board_param.reverse[board[i]];
        return -nega_alpha(n_board, depth, -beta, -alpha, skip_cnt + 1, o_open_val, p_open_val, o_cnt, p_cnt - 1);
    }
    if (canput > 1)
        sort(lst, lst + canput, cmp);
    for (i = 0; i < canput; ++i){
        g = -nega_alpha(lst[i].b, depth - 1, -beta, -alpha, 0, o_open_val, lst[i].n_open_val, o_cnt, p_cnt);
        if (fabs(g) == inf)
            return -inf;
        if (beta < g){
            register_hash(search_param.memo_lb, board, hash, g);
            return g;
        }
        alpha = max(alpha, g);
        v = max(v, g);
    }
    if (v == alpha)
        register_hash(search_param.memo_lb, board, hash, v);
    register_hash(search_param.memo_ub, board, hash, v);
    return v;
}

double nega_scout(int *board, int depth, double alpha, double beta, int skip_cnt, double p_open_val, double o_open_val, int p_cnt, int o_cnt){
    if (tim() - search_param.strt > search_param.tl)
        return -inf;
    if (depth < simple_threshold)
        return nega_alpha_light(board, depth, alpha, beta, skip_cnt, p_open_val, o_open_val, p_cnt, o_cnt);
    ++search_param.searched_nodes;
    if (skip_cnt == 2)
        return end_game(board);
    if (depth == 0)
        return evaluate(board, p_open_val / max(1, p_cnt) - o_open_val / max(1, o_cnt));
    int hash = calc_hash(board);
    double lb, ub;
    lb = get_val_hash(search_param.memo_lb, board, hash);
    ub = get_val_hash(search_param.memo_ub, board, hash);
    if (lb != -inf){
        alpha = max(alpha, lb);
        if (alpha >= beta)
            return alpha;
    }
    if (ub != -inf){
        beta = min(beta, ub);
        if (alpha >= beta)
            return beta;
    }
    int i, j, canput = 0;
    board_priority lst[30];
    int n_p_cnt = p_cnt + 1, n_depth = depth - 1;
    double previous_val;
    for (j = 0; j < search_param.vacant_cnt; ++j){
        for (i = 0; i < board_param.put_idx_num[search_param.vacant_lst[j]]; ++i){
            if (board_param.legal[board[board_param.put_idx[search_param.vacant_lst[j]][i]]][board_param.put[search_param.vacant_lst[j]][board_param.put_idx[search_param.vacant_lst[j]][i]]]){
                previous_val = get_val_hash(search_param.previous_memo, lst[canput].b, calc_hash(lst[canput].b));
                if (previous_val != -inf){
                    lst[canput].priority = 1000.0 + previous_val;
                    lst[canput].n_open_val = p_open_val + eval_param.open_eval[move_open(board, lst[canput].b, search_param.vacant_lst[j])];
                } else {
                    lst[canput].priority = eval_param.open_eval[move_open(board, lst[canput].b, search_param.vacant_lst[j])];
                    lst[canput].n_open_val = p_open_val + lst[canput].priority;
                }
                ++canput;
                break;
            }
        }
    }
    if (canput == 0){
        int n_board[board_index_num];
        for (i = 0; i < board_index_num; ++i)
            n_board[i] = board_param.reverse[board[i]];
        return -nega_scout(n_board, depth, -beta, -alpha, skip_cnt + 1, o_open_val, p_open_val, o_cnt, p_cnt);
    }
    if (canput > 2)
        sort(lst, lst + canput, cmp);
    double v, g;
    g = -nega_scout(lst[0].b, n_depth, -beta, -alpha, 0, o_open_val, lst[0].n_open_val, o_cnt, n_p_cnt);
    if (fabs(g) == inf)
        return -inf;
    if (beta <= g)
        return g;
    v = g;
    alpha = max(alpha, g);
    for (i = 1; i < canput; ++i){
        g = -nega_alpha(lst[i].b, n_depth, -alpha - window, -alpha, 0, o_open_val, lst[i].n_open_val, o_cnt, n_p_cnt);
        if (fabs(g) == inf)
            return -inf;
        if (beta <= g)
            return g;
        if (alpha < g){
            alpha = g;
            g = -nega_scout(lst[i].b, n_depth, -beta, -alpha, 0, o_open_val, lst[i].n_open_val, o_cnt, n_p_cnt);
            if (beta <= g)
                return g;
            alpha = max(alpha, g);
        }
        v = max(v, g);
    }
    return v;
}

double nega_scout_heavy(int *board, int depth, double alpha, double beta, int skip_cnt, double p_open_val, double o_open_val, int p_cnt, int o_cnt){
    if (tim() - search_param.strt > search_param.tl)
        return -inf;
    if (depth <= search_param.max_depth - 3)
        return nega_scout(board, depth, alpha, beta, skip_cnt, p_open_val, o_open_val, p_cnt, o_cnt);
    ++search_param.searched_nodes;
    if (skip_cnt == 2)
        return end_game(board);
    if (depth == 0)
        return evaluate(board, p_open_val / max(1, p_cnt) - o_open_val / max(1, o_cnt));
    int hash = calc_hash(board);
    double lb, ub;
    lb = get_val_hash(search_param.memo_lb, board, hash);
    ub = get_val_hash(search_param.memo_ub, board, hash);
    if (lb != -inf){
        alpha = max(alpha, lb);
        if (alpha >= beta)
            return alpha;
    }
    if (ub != -inf){
        beta = min(beta, ub);
        if (alpha >= beta)
            return beta;
    }
    int i, j, canput = 0;
    board_priority lst[30];
    int n_p_cnt = p_cnt + 1, n_depth = depth - 1;
    open_vals tmp_open_vals;
    double previous_val;
    for (j = 0; j < search_param.vacant_cnt; ++j){
        for (i = 0; i < board_param.put_idx_num[search_param.vacant_lst[j]]; ++i){
            if (board_param.legal[board[board_param.put_idx[search_param.vacant_lst[j]][i]]][board_param.put[search_param.vacant_lst[j]][board_param.put_idx[search_param.vacant_lst[j]][i]]]){
                lst[canput].n_open_val = p_open_val + eval_param.open_eval[move_open(board, lst[canput].b, search_param.vacant_lst[j])];
                previous_val = get_val_hash(search_param.previous_memo, lst[canput].b, calc_hash(lst[canput].b));
                if (previous_val != -inf){
                    lst[canput].priority = 1000.0 + previous_val;
                } else {
                    tmp_open_vals = open_val_forward(lst[canput].b, 1, true);
                    //cerr << tmp_open_vals.p_cnt << " " << tmp_open_vals.p_open_val << " " << tmp_open_vals.o_cnt << " " << tmp_open_vals.o_open_val << endl;
                    if (o_cnt + tmp_open_vals.p_cnt)
                        lst[canput].priority = (lst[canput].n_open_val + tmp_open_vals.o_open_val) / (n_p_cnt + tmp_open_vals.o_cnt) - (o_open_val + tmp_open_vals.p_open_val) / (o_cnt + tmp_open_vals.p_cnt);
                    else
                        lst[canput].priority = (lst[canput].n_open_val + tmp_open_vals.o_open_val) / (n_p_cnt + tmp_open_vals.o_cnt);
                }
                ++canput;
                break;
            }
        }
    }
    if (canput == 0){
        int n_board[board_index_num];
        for (i = 0; i < board_index_num; ++i)
            n_board[i] = board_param.reverse[board[i]];
        return -nega_scout_heavy(n_board, depth, -beta, -alpha, skip_cnt + 1, o_open_val, p_open_val, o_cnt, p_cnt);
    }
    if (canput > 2)
        sort(lst, lst + canput, cmp);
    double v, g;
    g = -nega_scout_heavy(lst[0].b, n_depth, -beta, -alpha, 0, o_open_val, lst[0].n_open_val, o_cnt, n_p_cnt);
    if (fabs(g) == inf)
        return -inf;
    if (beta <= g)
        return g;
    v = g;
    alpha = max(alpha, g);
    for (i = 1; i < canput; ++i){
        g = -nega_alpha(lst[i].b, n_depth, -alpha - window, -alpha, 0, o_open_val, lst[i].n_open_val, o_cnt, n_p_cnt);
        if (fabs(g) == inf)
            return -inf;
        if (beta <= g)
            return g;
        if (alpha < g){
            alpha = g;
            g = -nega_scout_heavy(lst[i].b, n_depth, -beta, -alpha, 0, o_open_val, lst[i].n_open_val, o_cnt, n_p_cnt);
            if (beta <= g)
                return g;
            alpha = max(alpha, g);
        }
        v = max(v, g);
    }
    return v;
}

double map_double(double y1, double y2, double y3, double x){
    double a, b, c;
    double x1 = 4.0 / hw2, x2 = 25.0 / hw2, x3 = 64.0 / hw2;
    a = ((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2)) / ((x1 - x2) * (x1 - x3) * (x2 - x3));
    b = (y1 - y2) / (x1 - x2) - a * (x1 + x2);
    c = y1 - a * x1 * x1 - b * x1;
    return a * x * x + b * x + c;
}

double map_linar(double s, double e, double x){
    return s + (e - s) * x;
}

int cmp_main(board_priority_move p, board_priority_move q){
    return p.priority > q.priority;
}

int cmp_vacant(int p, int q){
    return eval_param.weight[p] > eval_param.weight[q];
}

int main(){
    int outy, outx, i, j, k, canput, former_depth = 7, former_vacant = hw2 - 4;
    double score, max_score;
    unsigned long long p, o;
    int board[board_index_num];
    int put;
    vector<board_priority_move> lst;
    char elem;
    int action_count;
    double game_ratio;
    int ai_player;
    int board_tmp;
    int y, x;
    double final_score;
    int board_size;
    string action;

    cerr << "start AI" << endl;

    init();
    cerr << "AI initialized" << endl;
    prob_init();
    
    while (true){
        outy = -1;
        outx = -1;
        search_param.vacant_cnt = 0;
        p = 0;
        o = 0;
        canput = 0;
        cin >> ai_player;
        cin >> search_param.tl;
        cerr << "AI: " << ai_player << " timeout in " << search_param.tl << "ms" << endl;
        for (i = 0; i < hw2; ++i){
            cin >> elem;
            cerr << elem;
            if (elem == '.')
                search_param.vacant_lst[search_param.vacant_cnt++] = i;
            else{
                p |= (unsigned long long)(elem == '0') << i;
                o |= (unsigned long long)(elem == '1') << i;
            }
        }
        if (search_param.vacant_cnt > 1)
            sort(search_param.vacant_lst, search_param.vacant_lst + search_param.vacant_cnt, cmp_vacant);
        if (ai_player == 1)
            swap(p, o);
        search_param.strt = tim();
        for (i = 0; i < board_index_num; ++i){
            board_tmp = 0;
            for (j = 0; j < board_param.pattern_space[i]; ++j){
                if (1 & (p >> board_param.board_translate[i][j]))
                    board_tmp += board_param.pow3[j];
                else if (1 & (o >> board_param.board_translate[i][j]))
                    board_tmp += 2 * board_param.pow3[j];
            }
            board[i] = board_tmp;
        }
        search_param.min_max_depth = min(10, former_depth + search_param.vacant_cnt - former_vacant);            
        search_param.max_depth = search_param.min_max_depth;
        former_vacant = search_param.vacant_cnt;
        lst.clear();
        for (j = 0; j < search_param.vacant_cnt; ++j){
            for (i = 0; i < board_index_num; ++i){
                if (board_param.put[search_param.vacant_lst[j]][i] != -1){
                    if (board_param.legal[board[i]][board_param.put[search_param.vacant_lst[j]][i]]){
                        ++canput;
                        board_priority_move tmp;
                        tmp.open_val = eval_param.open_eval[move_open(board, tmp.b, search_param.vacant_lst[j])];
                        tmp.priority = tmp.open_val;
                        tmp.move = search_param.vacant_lst[j];
                        lst.push_back(tmp);
                        break;
                    }
                }
            }
        }
        cerr << "canput " << canput << endl;
        for (i = 0; i < canput; ++i)
            cerr << lst[i].move << " ";
        cerr << endl;
        if (canput > 1)
            sort(lst.begin(), lst.end(), cmp_main);
        outy = -1;
        outx = -1;
        search_param.searched_nodes = 0;
        while (tim() - search_param.strt < search_param.tl){
            hash_table_init(search_param.previous_memo);
            //hash_table_copy(search_param.previous_memo, search_param.memo_ub);
            swap(search_param.previous_memo, search_param.memo_ub);
            hash_table_init(search_param.memo_lb);
            //hash_table_init(search_param.memo_ub);
            search_param.turn = min(63, hw2 - search_param.vacant_cnt + search_param.max_depth);
            game_ratio = (double)search_param.turn / hw2;
            eval_param.pattern_weight = map_double(eval_param.weight_sme[0], eval_param.weight_sme[1], eval_param.weight_sme[2], game_ratio);
            eval_param.cnt_weight = map_double(eval_param.weight_sme[3], eval_param.weight_sme[4], eval_param.weight_sme[5], game_ratio);
            eval_param.canput_weight = map_double(eval_param.weight_sme[6], eval_param.weight_sme[7], eval_param.weight_sme[8], game_ratio);
            eval_param.weight_weight = map_double(eval_param.weight_sme[9], eval_param.weight_sme[10], eval_param.weight_sme[11], game_ratio);
            eval_param.confirm_weight = map_double(eval_param.weight_sme[12], eval_param.weight_sme[13], eval_param.weight_sme[14], game_ratio);
            eval_param.pot_canput_weight = map_double(eval_param.weight_sme[15], eval_param.weight_sme[16], eval_param.weight_sme[17], game_ratio);
            eval_param.open_weight = map_double(eval_param.weight_sme[18], eval_param.weight_sme[19], eval_param.weight_sme[20], game_ratio);
            for (i = 0; i < pattern_num; ++i)
                eval_param.pattern_each_weight[i] = map_double(eval_param.weight_sme[21 + i * 3], eval_param.weight_sme[22 + i * 3], eval_param.weight_sme[23 + i * 3], game_ratio);
            score = -nega_scout_heavy(lst[0].b, search_param.max_depth - 1, -65000.0, 65000.0, 0, 0.0, lst[0].open_val, 0, 1);
            if (fabs(score) == inf){
                max_score = -inf;
            } else {
                max_score = score;
                lst[0].priority = score;
                for (i = 1; i < canput; ++i){
                    score = -nega_alpha(lst[i].b, search_param.max_depth - 1, -max_score - window, -max_score, 0, 0.0, lst[i].open_val, 0, 1);
                    if (max_score <= score){
                        max_score = score;
                        score = -nega_scout_heavy(lst[i].b, search_param.max_depth - 1, -65000.0, -max_score, 0, 0.0, lst[i].open_val, 0, 1);
                        if (fabs(score) == inf){
                            max_score = -inf;
                            break;
                        }
                        lst[i].priority = score;
                        max_score = score;
                    } else
                        lst[i].priority = score;
                }
            }
            if (max_score == -inf){
                cerr << "depth " << search_param.max_depth << " timeoout" << endl;
                break;
            }
            final_score = max_score;
            former_depth = search_param.max_depth;
            if (canput > 1)
                sort(lst.begin(), lst.end(), cmp_main);
            outx = lst[0].move % hw;
            outy = lst[0].move / hw;
            cerr << "depth " << search_param.max_depth << " nodes " << search_param.searched_nodes << " nps " << ((unsigned long long)search_param.searched_nodes * 1000 / max(1, tim() - search_param.strt));
            cerr << "  " << outy << outx << " " << lst[0].priority;
            cerr << " time " << tim() - search_param.strt << endl;
            if (fabs(max_score) >= 1000.0 || search_param.max_depth >= hw2){
                cerr << "game end" << endl;
                break;
            }
            ++search_param.max_depth;
        }
        cerr << (char)(outx + 97) << (outy + 1) << endl;
        cerr << tim() - search_param.strt << endl;
        //cout << (char)(outx + 97) << (outy + 1) << " " << "MSG " << former_depth << " " << final_score << endl;
        cout << outy << " " << outx << endl;
    }
    return 0;
}
